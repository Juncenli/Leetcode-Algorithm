Question Number,Question Name,Tag,Time Using,Conclusion,Complexity,URL
217,Contains Duplicate,"Array, HashSet",1mins,set.add() 的简单运用,Time O(n) Space O(n),https://leetcode.com/problems/contains-duplicate/description/
242,Valid Anagram,"Array, HashSet",1mins,,,https://leetcode.com/problems/valid-anagram/description/
1,Two Sum,"Array, HashSet",1mins,,,https://leetcode.com/problems/two-sum/description/
49,Group Anagrams,"Array, HashSet",2mins,可以用char[] arr来记录cnt，这样new string的时候 可以直接用,,https://leetcode.com/problems/group-anagrams/description/
347,Top K Frequent Elements,"Array, QuickSelect",12mins,quickSelect 模版题,Time O(n) Space O(n),https://leetcode.com/problems/top-k-frequent-elements/description/
238,Product of Array Except Self,Array,"8mins

一开始res[i] indicates: 左边的product except itself

注意两个for loop的起始值","    public int[] productExceptSelf(int[] nums) {
        int len = nums.length;
        int[] res = new int[len];
        res[0] = 1;
        // [1, 1, 2, 6]
        for (int i = 1; i < len; i++) {
            res[i] = res[i - 1] * nums[i - 1];
        }
        int rightProduct = 1;
        // [24, 12, 8, 6]
        for (int i = len - 2; i >= 0; i--) {
            rightProduct *= nums[i + 1];
            res[i] *= rightProduct;
        }
        return res;
    }",,https://leetcode.com/problems/product-of-array-except-self/
36,Valid Sudoku,Array,6mins,"开辟额外数组来进行记录

遇到重复，那么return false","Time O(1) Space O(1)

constant",https://leetcode.com/problems/valid-sudoku/
271,Encode and Decode Strings,String,"8mins

len + delimiter + word

s.indexOf(”Delimiter”, startIdx)","    public String encode(List<String> strs) {
        StringBuilder sb = new StringBuilder();
        for (String str : strs) {
            int len = str.length();
            sb.append(len).append(""/"").append(str);
        }
        return sb.toString();
    }

    // Decodes a single string to a list of strings.
    public List<String> decode(String s) {
        int idxEnd = 0;
        List<String> res = new ArrayList<>();
        while (idxEnd < s.length()) {
            int idxDelimiter = s.indexOf(""/"", idxEnd);
            // 5/word1
            int len = Integer.parseInt(s.substring(idxEnd, idxDelimiter));
            idxEnd = idxDelimiter + len + 1;
            String word = s.substring(idxDelimiter + 1, idxEnd);
            res.add(word);
        }
        return res;
    }",,
128,Longest Consecutive Sequence,"Array, HashSet","3mins

","注意edge case 原本数组可能为空

所以初始化 int maxLen = 0;",Time O(n) Space O(n),https://leetcode.com/problems/longest-consecutive-sequence/description/
125,Valid Palindrome,"String, Two Pointer",1mins,,,
167,Two Sum II - Input Array Is Sorted,Two Pointer,3mins,"sort 过后的 一定得想到two point来逼近

另外一个是二分法",Time O(n) Space O(1),https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/
15,3Sum,Two Pointer,8mins,"注意去重

使用 continue 和 while

while (left < right && nums[right] == nums[--right]);

while (left < right && nums[left] == nums[++left]);

因为right和left本来就要移动，所以可以使用此写法",Time O(nlogn+n^2),https://leetcode.com/problems/3sum/
11,Container With Most Water,Two Pointer,2mins,"当宽变小，只有高点大，才能使得面积变大的可能

所以pointer移动规则，height低的移动",Time O(n) Space O(1),https://leetcode.com/problems/container-with-most-water/description/
42,Trapping Rain Water,Two Pointer,"Forgot the details

首尾双指针保持左右边界高度","    public int trap(int[] height) {
        int len = height.length;
        int left = 0, right = len - 1;
        int sum = 0;
        int leftMax = 0, rightMax = 0;
        // 首尾双指针，为了保持左右高度的边界
        while (left < right) {
            leftMax = Math.max(leftMax, height[left]);
            rightMax = Math.max(rightMax, height[right]);
            // 在脑海中构造接雨水的过程
            if (leftMax <= rightMax) {
                // 取小的且移动
                sum += leftMax - height[left];
                left++;
            } else {
                sum += rightMax - height[right];
                right--;
            }
        }
        return sum;
    }",Time O(n) Space O(1),https://leetcode.com/problems/trapping-rain-water/
121,Best Time to Buy and Sell Stock,Array,1mins,,Time O(n) Space O(1),https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/
3,Longest Substring Without Repeating Characters,"HashMap, Sliding Window",3mins,"shrink condition

while (cntMap.get(curr) > 1)",Time O(n) Space O(n),https://leetcode.com/problems/longest-substring-without-repeating-characters/description/
424,Longest Repeating Character Replacement,"Greedy, HashMap, Sliding Window","5mins

保留窗口了cnt最多的character → 使得最长","1、什么时候应该扩大窗口？
2、什么时候应该缩小窗口？
3、什么时候得到一个合法的答案？
针对本题，以上三个问题的答案是：
1、当可替换次数大于 0 时，扩大窗口，所有进入窗口的字符都进行替换，使得窗口内的所有元素都是重复的。
2、当可替换次数小于 0 时，缩小窗口，空余出更多可替换次数，以便之后继续扩大窗口。
3、只要可替换次数大于等于 0，窗口中的字符串都是重复的，我们想求的是一个最大窗口长度。


不用更新 windowMaxCount
因为只有 windowMaxCount 变得更大的时候才可能获得更长的重复子串，才会更新 res",Time O(n) Space O(n),https://leetcode.com/problems/longest-repeating-character-replacement/description/
567,Permutation in String,"HashMap, Sliding Window",10mins,"需要两个hashmap来分别记录

return trueif one of s1's permutations is the substring of s2  → 本质是anagram

当窗口的长度等于s1的时候，进行收缩

    public boolean checkInclusion(String s1, String s2) {
        // 本质是anagram
        if (s2.length() < s1.length()) return false;
        Map<Character, Integer> neededMap = new HashMap<>();
        for (char c : s1.toCharArray()) {
            neededMap.put(c, neededMap.getOrDefault(c, 0) + 1);
        }
        int valid = 0;
        Map<Character, Integer> windowMap = new HashMap<>();
        int left = 0, right = 0, len = s2.length();
        while (right < len) {
            char curr = s2.charAt(right);
            windowMap.put(curr, windowMap.getOrDefault(curr, 0) + 1);
            if (windowMap.get(curr).equals(neededMap.get(curr))) {
                valid++;
            }
            right++;
            if (right - left == s1.length()) {
                if (valid == neededMap.size()) return true;
                char remove = s2.charAt(left);
                if (windowMap.get(remove).equals(neededMap.get(remove))) {
                    valid--;
                }
                windowMap.put(remove, windowMap.get(remove) - 1);
                left++;
            }
        }
        return false;
    }",Time O(n) Space O(n),https://leetcode.com/problems/permutation-in-string/
76,Minimum Window Substring,"HashMap, Sliding Window",8mins,经典模版题,Time O(m+n),https://leetcode.com/problems/minimum-window-substring/description/
239,Sliding Window Maximum,"MaxQueue, Sliding Window",8mins,"利用deque来实现mxaQueue, 这样就能保持窗口中的最大值

    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer> maxQueue = new ArrayDeque<>();
        int left = 0, right = 0, len = nums.length;
        int[] maxArr = new int[len - k + 1];
        int p = 0;
        while (right < len) {
            int curr = nums[right];
            // maxQueue: max -> min
            while (!maxQueue.isEmpty() && curr > maxQueue.peekLast()) {
                maxQueue.pollLast();
            }
            maxQueue.offerLast(curr);
            right++;
            if (right - left > k) {
                int remove = nums[left];
                if (remove == maxQueue.peekFirst()) {
                    maxQueue.pollFirst();
                }
                left++;
            }
            if (right - left == k) {
                maxArr[p++] = maxQueue.peekFirst();
            }
        }
        return maxArr;
    }",Time O(n) Space O(n),https://leetcode.com/problems/sliding-window-maximum/description/
20,Valid Parentheses,"HashMap, Stack",3mins,right parentheses是key， left是value,Time O(n) Space O(n),https://leetcode.com/problems/valid-parentheses/description/
155,Min Stack,Stack,5mins,"Deque<Integer> origin;
Deque<Integer> minStk;

minStk的作用是保持最小状态",,https://leetcode.com/problems/min-stack/description/
150,Evaluate Reverse Polish Notation,Stack,"8mins

如果要使用deque来模拟stack，那么一定要使用offerLast and pollLast, 这样才不会出错","    public int evalRPN(String[] tokens) {
        Deque<Integer> stk = new ArrayDeque<>();
        for (String token : tokens) {
            if (token.equals(""*"") || token.equals(""/"") || token.equals(""+"") || token.equals(""-"")) {
                int num1 = stk.pollLast();
                int num2 = stk.pollLast();
                switch (token) {
                    case ""+"":
                        stk.offerLast(num2 + num1);
                        break;
                    case ""-"" :
                        stk.offerLast(num2 - num1);
                        break;
                    case ""*"" :
                        stk.offerLast(num2 * num1);
                        break;
                    default :
                        stk.offerLast(num2 / num1);
                        break;
                }
            } else {
                stk.offerLast(Integer.parseInt(token));
            }
        }
        return stk.pollLast();
    }",,https://leetcode.com/problems/evaluate-reverse-polish-notation/description/
22,Generate Parentheses,Backtracking,"10mins


注意添加parentheses的顺序和条件","    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();
        backtracking(res, new StringBuilder(), 0, 0, n);
        return res;
    }

    public void backtracking(List<String> res, StringBuilder sb, int leftCnt, int rightCnt, int n) {
        if (leftCnt == n && rightCnt == n) {
            res.add(sb.toString());
            return;
        }

        if (leftCnt < n) {
            sb.append(""("");
            backtracking(res, sb, leftCnt + 1, rightCnt, n);
            sb.setLength(sb.length() - 1);
        }

        if (rightCnt < leftCnt) {
            sb.append("")"");
            backtracking(res, sb, leftCnt, rightCnt + 1, n);
            sb.setLength(sb.length() - 1);
        }
    }",,https://leetcode.com/problems/generate-parentheses/description/
140,Word Break II,Backtracking,直接backtracking暴力搜索,"public List<String> wordBreak(String s, List<String> wordDict) {
        StringBuilder sb = new StringBuilder();
        List<String> res = new ArrayList<>();
        Set<String> dict = new HashSet<>();
        for (String word : wordDict) {
            dict.add(word);
        }
        backtracking(res, sb, dict, s, 0);
        return res;
    }

    public void backtracking(List<String> res, StringBuilder sb, Set<String> dict, String s, int idx) {
        if (idx == s.length()) {
            String temp = sb.toString();
            res.add(temp.substring(0, temp.length() -1));
            return;
        }
        for (int i = idx; i < s.length(); i++) {
            String token = s.substring(idx, i + 1);
            if (!dict.contains(token)) continue;
            int len = sb.length();
            sb.append(token);
            sb.append("" "");
            backtracking(res, sb, dict, s, i + 1);
            sb.setLength(len);
        }
    }",,https://leetcode.com/problems/word-break-ii/
739,Daily Temperatures,Stack,"5mins

monotonic （/ˌmɑnəˈtɑnɪk/） stack的运用， 放入的是idx",模版框架 for → while （pop）,Time O(n) Space O(n),https://leetcode.com/problems/daily-temperatures/
853,Car Fleet,Stack,"单调最大栈

在后面的车子: 到达终点所用的时间小于前面的车子，则一定能形成车队","    public int carFleet(int target, int[] position, int[] speed) {
        int len = position.length;
        int[][] cars = new int[len][2];
        for (int i = 0; i < len; i++) {
            cars[i][0] = position[i];
            cars[i][1] = speed[i];
        }
        Arrays.sort(cars, (n1, n2) -> (n1[0] - n2[0]));
        Stack<Double> stk = new Stack<>();
        // maxStack max -> min
        for (int i = 0; i < len; i++) {
            double time = (target - cars[i][0]) / (double)cars[i][1];
            while (!stk.isEmpty() && stk.peek() <= time) {
                stk.pop();
            }
            stk.push(time);
        }
        return stk.size();
    }",,https://leetcode.com/problems/car-fleet/description/
84,Largest Rectangle in Histogram,Stack,"单调最大栈，放入的是idx

min height → max height

当遇到一个更小的height时，会pop出左边界，preIdx = peek() 这时宽度 i -preIdx - 1, 高度是arr[左边界]

去掉重复计算","public int largestRectangleArea(int[] heights) {
    int len = heights.length;
    int[] arr = new int[len + 2];
    for (int i = 1; i <= len; i++) {
        arr[i] = heights[i - 1];
    }
    int maxArea = 0;
    Stack<Integer> monoMinStk = new Stack<>();
    for (int i = 0; i < arr.length; i++) {
         int currHeight = arr[i];
         while (!monoMinStk.isEmpty() && arr[monoMinStk.peek()] > currHeight) {
              int leftBoundaryIdx = monoMinStk.pop();
              int preIdx = monoMinStk.peek();
              int width = i - preIdx - 1;
              maxArea = Math.max(maxArea, width * arr[leftBoundaryIdx]);
          }
      monoMinStk.push(i);
     }
   return maxArea;
}",Time O(n) Space O(n),https://leetcode.com/problems/largest-rectangle-in-histogram/description/
704,Binary Search,BinarySearch,二分模版,,Time O(logn) Space O(1),https://leetcode.com/problems/binary-search/description/
74,Search a 2D Matrix,BinarySearch,5mins,"把二维二分搜索压缩成一维度的

int left = 0, right = m * n - 1;

int mid = left + (right - left) / 2;
int x = mid / n;
int y = mid % n;",O(log(m * n)),https://leetcode.com/problems/search-a-2d-matrix/description/
875,Koko Eating Bananas,BinarySearch,"难点在于如何构造单调递减函数

f(x)是关于速度x的单调递减函数(速度越快所用时间越短)，然后求左边界[1, maxSpeed]","public int minEatingSpeed(int[] piles, int h) {
        // the eating speed of koko is x, the y is the time of eating all of bananas. 
        // Monotonically decreasing function f(x) = ax + b;
        // binary search -> find the speed 

        int left = 1, right = 1000000001;
        // 求左边界
        while (left ≤ right) {
            int mid = left + (right - left) / 2;
            // 目标是速度越小时间尽量长，但满足要求
            if (f(piles, mid) <= h) {
                // 速度减小
                right = mid - 1;
            } else {
                // 总时间大于h，速度要加快
                left = mid + 1;
            }
        }
        return left;
    }

    public long f(int[] piles, int x) {
        long hours = 0;
        for (int i = 0; i < piles.length; i++) {
            // 都用整个小时吃完当前这棵树
            hours += piles[i] / x;
            if (piles[i] % x > 0) {
                hours++;
            }
        }
        return hours;
    }",O(n⋅logm),https://leetcode.com/problems/koko-eating-bananas/
153,Find Minimum in Rotated Sorted Array,BinarySearch,二分法模版：和nums[right]做比较,"public int findMin(int[] nums) {
     int len = nums.length;
     int left = 0, right = len - 1;
     while (left < right) {
         int mid = left + (right - left) / 2;
         if (nums[mid] > nums[right]) {
              left = mid + 1;
         }  else {
              right = mid;
         }
       }
   return nums[left];
}",logn,https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/
33,Search in Rotated Sorted Array,BinarySearch,先找到pivot，然后在左右区间分别搜索target（因为pivot的值是最小值）,,,https://leetcode.com/problems/search-in-rotated-sorted-array/description/
981,Time Based Key-Value Store,BinarySearch,,,,https://leetcode.com/problems/time-based-key-value-store/description/
4,Median of Two Sorted Arrays,BinarySearch,"注意edge cases的处理

明白题意","class TimeMap {
    private Map<String, List<Element>> timeMap;
    public TimeMap() {
        timeMap = new HashMap<>();
    }
    
    public void set(String key, String value, int timestamp) {
        List<Element> list = timeMap.getOrDefault(key, new ArrayList<>());
        list.add(new Element(value, timestamp));
        timeMap.put(key, list);
    }
    
    public String get(String key, int timestamp) {
        List<Element> list = timeMap.get(key);
        if (list == null) return """";
        int left = 0, right = list.size() - 1;
        // 查找时间，移动index
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (list.get(mid).timestamp > timestamp) {
                right = mid - 1;
            }
            else if (list.get(mid).timestamp < timestamp) {
                left = mid + 1;
            }
            else return list.get(mid).value;
        }
        // left是key对应的timestamp应该在的位置，我们应该找prev，所以减1 （因为没有exactly timestamp一样的value）
        if (left - 1 < 0) return """"; // 越界不合法
        return list.get(left - 1).value;
    }
}

class Element {
    String value;
    int timestamp;
    public Element(String value, int timestamp) {
        this.value = value;
        this.timestamp = timestamp;
    }
}",,https://leetcode.com/problems/median-of-two-sorted-arrays/description/
4,Median of Two Sorted Arrays,BinarySearch,,,,https://leetcode.com/problems/median-of-two-sorted-arrays/description/
206,Reverse Linked List,"LinkedList, Recursion",1mins,,,
21,Merge Two Sorted Lists,"LinkedList, Two Pointer",1mins,,,https://leetcode.com/problems/merge-two-sorted-lists/description/
143,Reorder List,"LinkedList, Stack",5mins,"需要一个stack来得到lastnode, 还有三个指针在不停的变换，curr, next, last

while break的条件(next == last || next == last.next) 奇偶数",,https://leetcode.com/problems/reorder-list/description/
19,Remove Nth Node From End of List,"DummyNode, LinkedList, Two Pointer",pay attention on details,"需要使用双指针，实现one pass

我们找的是前一个node，所以还要考虑原本链表没有前一个node的情况，所以需要dummy先给原链表接上

return dummy.next",,https://leetcode.com/problems/remove-nth-node-from-end-of-list/
138,Copy List with Random Pointer,"Deep Copy, LinkedList",8mins,"deep copy的题都要用bfs和map

类似于copy graph，动作同步

class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) return null;
        Map<Node, Node> copyMap = new HashMap<>();
        Queue<Node> bfsQueue = new LinkedList<>();
        bfsQueue.offer(head);
        copyMap.put(head, new Node(head.val));
        while (!bfsQueue.isEmpty()) {
            Node curr = bfsQueue.poll();
            Node copyCurr = copyMap.get(curr);
            if (curr.random != null && !copyMap.containsKey(curr.random)) {
                bfsQueue.offer(curr.random);
                Node copyNode = new Node(curr.random.val);
                copyMap.put(curr.random, copyNode);
            }
            if (curr.next != null && !copyMap.containsKey(curr.next)) {
                bfsQueue.offer(curr.next);
                Node copyNode = new Node(curr.next.val);
                copyMap.put(curr.next, copyNode);
            }
            Node copyNext = copyMap.get(curr.next);
            Node copyRandom = copyMap.get(curr.random);
            copyCurr.next = copyNext;
            copyCurr.random = copyRandom;
        }
        return copyMap.get(head);
    }
}",,https://leetcode.com/problems/copy-list-with-random-pointer/description/
2,Add Two Numbers,"DummyNode, LinkedList, Two Pointer",5mins,while (l1 != null || l2 != null || carry != 0),,https://leetcode.com/problems/add-two-numbers/description/
141,Linked List Cycle,"LinkedList, Two Pointer",1mins,,,https://leetcode.com/problems/linked-list-cycle/description/
287,Find the Duplicate Number,"Floyd's Algorithm, LinkedList, Two Pointer",5mins,"public int findDuplicate(int[] nums) {
      int slowIdx = 0, fastIdx = 0; 
      while (true) {
            slowIdx = nums[slowIdx];
            fastIdx = nums[nums[fastIdx]];
            if (slowIdx == fastIdx) {
            int flag = 0;
            while (flag != slowIdx) {
                 flag = nums[flag];
                slowIdx = nums[slowIdx];
            }
         return flag;
       }
    }
}",Time O(n) Space O(1),https://leetcode.com/problems/find-the-duplicate-number/description/
146,LRU Cache,"DoubleLinkedList, HashMap",20mins,"需要自己建造DoubleLinkedList 对应有method →  moveToHead, removeNode, addToHead

注意细节","• Time complexity : O(1) both for put and get.

• Space complexity : O(capacity) since the space is used only for a hashmap and double linked list with at most capacity + 1 elements.",https://leetcode.com/problems/lru-cache/description/
23,Merge k Sorted Lists,"LinkedList, PriorityQueue",5mins,,,
25,Reverse Nodes in k-Group,"LinkedList, Recursion",forgot → 巧妙的使用递归,"    public ListNode reverseKGroup(ListNode head, int k) {
        if (head == null) return null;
        ListNode a = head, b = head;
        for (int i = 0; i < k; i++) {
            if (b == null) return a;
            b = b.next;
        }
        ListNode newHead = reverse(a, b);
        a.next = reverseKGroup(b, k);
        return newHead;
    }

    public ListNode reverse(ListNode a, ListNode b) {
        ListNode pre = null, temp = null;
        ListNode curr = a;
        while (curr != b) {
            temp = curr.next;
            curr.next = pre;
            pre = curr;
            curr = temp;
        }
        return pre;
    }",,https://leetcode.com/problems/reverse-nodes-in-k-group/description/