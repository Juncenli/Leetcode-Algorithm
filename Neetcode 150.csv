Question Number,Question Name,Tag,Time Using,Conclusion,Complexity,URL
217,Contains Duplicate,"Array, HashSet",1mins,set.add() 的简单运用,Time O(n) Space O(n),https://leetcode.com/problems/contains-duplicate/description/
242,Valid Anagram,"Array, HashSet",1mins,,,https://leetcode.com/problems/valid-anagram/description/
1,Two Sum,"Array, HashSet",1mins,,,https://leetcode.com/problems/two-sum/description/
49,Group Anagrams,"Array, HashSet",2mins,可以用char[] arr来记录cnt，这样new string的时候 可以直接用,,https://leetcode.com/problems/group-anagrams/description/
347,Top K Frequent Elements,"Array, QuickSelect",12mins,quickSelect 模版题,Time O(n) Space O(n),https://leetcode.com/problems/top-k-frequent-elements/description/
238,Product of Array Except Self,Array,"8mins

一开始res[i] indicates: 左边的product except itself

注意两个for loop的起始值","    public int[] productExceptSelf(int[] nums) {
        int len = nums.length;
        int[] res = new int[len];
        res[0] = 1;
        // [1, 1, 2, 6]
        for (int i = 1; i < len; i++) {
            res[i] = res[i - 1] * nums[i - 1];
        }
        int rightProduct = 1;
        // [24, 12, 8, 6]
        for (int i = len - 2; i >= 0; i--) {
            rightProduct *= nums[i + 1];
            res[i] *= rightProduct;
        }
        return res;
    }",,https://leetcode.com/problems/product-of-array-except-self/
36,Valid Sudoku,Array,6mins,"开辟额外数组来进行记录

遇到重复，那么return false","Time O(1) Space O(1)

constant",https://leetcode.com/problems/valid-sudoku/
271,Encode and Decode Strings,String,"8mins

len + delimiter + word

s.indexOf(”Delimiter”, startIdx)","    public String encode(List<String> strs) {
        StringBuilder sb = new StringBuilder();
        for (String str : strs) {
            int len = str.length();
            sb.append(len).append(""/"").append(str);
        }
        return sb.toString();
    }

    // Decodes a single string to a list of strings.
    public List<String> decode(String s) {
        int idxEnd = 0;
        List<String> res = new ArrayList<>();
        while (idxEnd < s.length()) {
            int idxDelimiter = s.indexOf(""/"", idxEnd);
            // 5/word1
            int len = Integer.parseInt(s.substring(idxEnd, idxDelimiter));
            idxEnd = idxDelimiter + len + 1;
            String word = s.substring(idxDelimiter + 1, idxEnd);
            res.add(word);
        }
        return res;
    }",,
128,Longest Consecutive Sequence,"Array, HashSet","3mins

","注意edge case 原本数组可能为空

所以初始化 int maxLen = 0;",Time O(n) Space O(n),https://leetcode.com/problems/longest-consecutive-sequence/description/
125,Valid Palindrome,"String, Two Pointer",1mins,,,
167,Two Sum II - Input Array Is Sorted,Two Pointer,3mins,"sort 过后的 一定得想到two point来逼近

另外一个是二分法",Time O(n) Space O(1),https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/
15,3Sum,Two Pointer,8mins,"注意去重

使用 continue 和 while

while (left < right && nums[right] == nums[--right]);

while (left < right && nums[left] == nums[++left]);

因为right和left本来就要移动，所以可以使用此写法",Time O(nlogn+n^2),https://leetcode.com/problems/3sum/
11,Container With Most Water,Two Pointer,2mins,"当宽变小，只有高点大，才能使得面积变大的可能

所以pointer移动规则，height低的移动",Time O(n) Space O(1),https://leetcode.com/problems/container-with-most-water/description/
42,Trapping Rain Water,Two Pointer,"Forgot the details

首尾双指针保持左右边界高度","    public int trap(int[] height) {
        int len = height.length;
        int left = 0, right = len - 1;
        int sum = 0;
        int leftMax = 0, rightMax = 0;
        // 首尾双指针，为了保持左右高度的边界
        while (left < right) {
            leftMax = Math.max(leftMax, height[left]);
            rightMax = Math.max(rightMax, height[right]);
            // 在脑海中构造接雨水的过程
            if (leftMax <= rightMax) {
                // 取小的且移动
                sum += leftMax - height[left];
                left++;
            } else {
                sum += rightMax - height[right];
                right--;
            }
        }
        return sum;
    }",Time O(n) Space O(1),https://leetcode.com/problems/trapping-rain-water/
121,Best Time to Buy and Sell Stock,Array,1mins,,Time O(n) Space O(1),https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/
3,Longest Substring Without Repeating Characters,"HashMap, Sliding Window",3mins,"shrink condition

while (cntMap.get(curr) > 1)",Time O(n) Space O(n),https://leetcode.com/problems/longest-substring-without-repeating-characters/description/
424,Longest Repeating Character Replacement,"Greedy, HashMap, Sliding Window","5mins

保留窗口了cnt最多的character → 使得最长","1、什么时候应该扩大窗口？
2、什么时候应该缩小窗口？
3、什么时候得到一个合法的答案？
针对本题，以上三个问题的答案是：
1、当可替换次数大于 0 时，扩大窗口，所有进入窗口的字符都进行替换，使得窗口内的所有元素都是重复的。
2、当可替换次数小于 0 时，缩小窗口，空余出更多可替换次数，以便之后继续扩大窗口。
3、只要可替换次数大于等于 0，窗口中的字符串都是重复的，我们想求的是一个最大窗口长度。


不用更新 windowMaxCount
因为只有 windowMaxCount 变得更大的时候才可能获得更长的重复子串，才会更新 res",Time O(n) Space O(n),https://leetcode.com/problems/longest-repeating-character-replacement/description/
567,Permutation in String,"HashMap, Sliding Window",10mins,"需要两个hashmap来分别记录

return trueif one of s1's permutations is the substring of s2  → 本质是anagram

当窗口的长度等于s1的时候，进行收缩

    public boolean checkInclusion(String s1, String s2) {
        // 本质是anagram
        if (s2.length() < s1.length()) return false;
        Map<Character, Integer> neededMap = new HashMap<>();
        for (char c : s1.toCharArray()) {
            neededMap.put(c, neededMap.getOrDefault(c, 0) + 1);
        }
        int valid = 0;
        Map<Character, Integer> windowMap = new HashMap<>();
        int left = 0, right = 0, len = s2.length();
        while (right < len) {
            char curr = s2.charAt(right);
            windowMap.put(curr, windowMap.getOrDefault(curr, 0) + 1);
            if (windowMap.get(curr).equals(neededMap.get(curr))) {
                valid++;
            }
            right++;
            if (right - left == s1.length()) {
                if (valid == neededMap.size()) return true;
                char remove = s2.charAt(left);
                if (windowMap.get(remove).equals(neededMap.get(remove))) {
                    valid--;
                }
                windowMap.put(remove, windowMap.get(remove) - 1);
                left++;
            }
        }
        return false;
    }",Time O(n) Space O(n),https://leetcode.com/problems/permutation-in-string/
76,Minimum Window Substring,"HashMap, Sliding Window",8mins,经典模版题,Time O(m+n),https://leetcode.com/problems/minimum-window-substring/description/
239,Sliding Window Maximum,"MaxQueue, Sliding Window",8mins,"利用deque来实现mxaQueue, 这样就能保持窗口中的最大值

    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer> maxQueue = new ArrayDeque<>();
        int left = 0, right = 0, len = nums.length;
        int[] maxArr = new int[len - k + 1];
        int p = 0;
        while (right < len) {
            int curr = nums[right];
            // maxQueue: max -> min
            while (!maxQueue.isEmpty() && curr > maxQueue.peekLast()) {
                maxQueue.pollLast();
            }
            maxQueue.offerLast(curr);
            right++;
            if (right - left > k) {
                int remove = nums[left];
                if (remove == maxQueue.peekFirst()) {
                    maxQueue.pollFirst();
                }
                left++;
            }
            if (right - left == k) {
                maxArr[p++] = maxQueue.peekFirst();
            }
        }
        return maxArr;
    }",Time O(n) Space O(n),https://leetcode.com/problems/sliding-window-maximum/description/
20,Valid Parentheses,"HashMap, Stack",3mins,right parentheses是key， left是value,Time O(n) Space O(n),https://leetcode.com/problems/valid-parentheses/description/
155,Min Stack,Stack,5mins,"Deque<Integer> origin;
Deque<Integer> minStk;

minStk的作用是保持最小状态",,https://leetcode.com/problems/min-stack/description/
150,Evaluate Reverse Polish Notation,Stack,"8mins

如果要使用deque来模拟stack，那么一定要使用offerLast and pollLast, 这样才不会出错","    public int evalRPN(String[] tokens) {
        Deque<Integer> stk = new ArrayDeque<>();
        for (String token : tokens) {
            if (token.equals(""*"") || token.equals(""/"") || token.equals(""+"") || token.equals(""-"")) {
                int num1 = stk.pollLast();
                int num2 = stk.pollLast();
                switch (token) {
                    case ""+"":
                        stk.offerLast(num2 + num1);
                        break;
                    case ""-"" :
                        stk.offerLast(num2 - num1);
                        break;
                    case ""*"" :
                        stk.offerLast(num2 * num1);
                        break;
                    default :
                        stk.offerLast(num2 / num1);
                        break;
                }
            } else {
                stk.offerLast(Integer.parseInt(token));
            }
        }
        return stk.pollLast();
    }",,https://leetcode.com/problems/evaluate-reverse-polish-notation/description/
22,Generate Parentheses,Backtracking,"10mins


注意添加parentheses的顺序和条件","    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();
        backtracking(res, new StringBuilder(), 0, 0, n);
        return res;
    }

    public void backtracking(List<String> res, StringBuilder sb, int leftCnt, int rightCnt, int n) {
        if (leftCnt == n && rightCnt == n) {
            res.add(sb.toString());
            return;
        }

        if (leftCnt < n) {
            sb.append(""("");
            backtracking(res, sb, leftCnt + 1, rightCnt, n);
            sb.setLength(sb.length() - 1);
        }

        if (rightCnt < leftCnt) {
            sb.append("")"");
            backtracking(res, sb, leftCnt, rightCnt + 1, n);
            sb.setLength(sb.length() - 1);
        }
    }",,https://leetcode.com/problems/generate-parentheses/description/
140,Word Break II,Backtracking,直接backtracking暴力搜索,"public List<String> wordBreak(String s, List<String> wordDict) {
        StringBuilder sb = new StringBuilder();
        List<String> res = new ArrayList<>();
        Set<String> dict = new HashSet<>();
        for (String word : wordDict) {
            dict.add(word);
        }
        backtracking(res, sb, dict, s, 0);
        return res;
    }

    public void backtracking(List<String> res, StringBuilder sb, Set<String> dict, String s, int idx) {
        if (idx == s.length()) {
            String temp = sb.toString();
            res.add(temp.substring(0, temp.length() -1));
            return;
        }
        for (int i = idx; i < s.length(); i++) {
            String token = s.substring(idx, i + 1);
            if (!dict.contains(token)) continue;
            int len = sb.length();
            sb.append(token);
            sb.append("" "");
            backtracking(res, sb, dict, s, i + 1);
            sb.setLength(len);
        }
    }",,https://leetcode.com/problems/word-break-ii/
739,Daily Temperatures,Stack,"5mins

monotonic （/ˌmɑnəˈtɑnɪk/） stack的运用， 放入的是idx",模版框架 for → while （pop）,Time O(n) Space O(n),https://leetcode.com/problems/daily-temperatures/
853,Car Fleet,Stack,"单调最大栈

在后面的车子: 到达终点所用的时间小于前面的车子，则一定能形成车队","    public int carFleet(int target, int[] position, int[] speed) {
        int len = position.length;
        int[][] cars = new int[len][2];
        for (int i = 0; i < len; i++) {
            cars[i][0] = position[i];
            cars[i][1] = speed[i];
        }
        Arrays.sort(cars, (n1, n2) -> (n1[0] - n2[0]));
        Stack<Double> stk = new Stack<>();
        // maxStack max -> min
        for (int i = 0; i < len; i++) {
            double time = (target - cars[i][0]) / (double)cars[i][1];
            while (!stk.isEmpty() && stk.peek() <= time) {
                stk.pop();
            }
            stk.push(time);
        }
        return stk.size();
    }",,https://leetcode.com/problems/car-fleet/description/
84,Largest Rectangle in Histogram,Stack,"单调最大栈，放入的是idx

min height → max height

当遇到一个更小的height时，会pop出左边界，preIdx = peek() 这时宽度 i -preIdx - 1, 高度是arr[左边界]

去掉重复计算","public int largestRectangleArea(int[] heights) {
    int len = heights.length;
    int[] arr = new int[len + 2];
    for (int i = 1; i <= len; i++) {
        arr[i] = heights[i - 1];
    }
    int maxArea = 0;
    Stack<Integer> monoMinStk = new Stack<>();
    for (int i = 0; i < arr.length; i++) {
         int currHeight = arr[i];
         while (!monoMinStk.isEmpty() && arr[monoMinStk.peek()] > currHeight) {
              int leftBoundaryIdx = monoMinStk.pop();
              int preIdx = monoMinStk.peek();
              int width = i - preIdx - 1;
              maxArea = Math.max(maxArea, width * arr[leftBoundaryIdx]);
          }
      monoMinStk.push(i);
     }
   return maxArea;
}",Time O(n) Space O(n),https://leetcode.com/problems/largest-rectangle-in-histogram/description/
704,Binary Search,BinarySearch,二分模版,,Time O(logn) Space O(1),https://leetcode.com/problems/binary-search/description/
74,Search a 2D Matrix,BinarySearch,5mins,"把二维二分搜索压缩成一维度的

int left = 0, right = m * n - 1;

int mid = left + (right - left) / 2;
int x = mid / n;
int y = mid % n;",O(log(m * n)),https://leetcode.com/problems/search-a-2d-matrix/description/
875,Koko Eating Bananas,BinarySearch,"难点在于如何构造单调递减函数

f(x)是关于速度x的单调递减函数(速度越快所用时间越短)，然后求左边界[1, maxSpeed]","public int minEatingSpeed(int[] piles, int h) {
        // the eating speed of koko is x, the y is the time of eating all of bananas. 
        // Monotonically decreasing function f(x) = ax + b;
        // binary search -> find the speed 

        int left = 1, right = 1000000001;
        // 求左边界
        while (left ≤ right) {
            int mid = left + (right - left) / 2;
            // 目标是速度越小时间尽量长，但满足要求
            if (f(piles, mid) <= h) {
                // 速度减小
                right = mid - 1;
            } else {
                // 总时间大于h，速度要加快
                left = mid + 1;
            }
        }
        return left;
    }

    public long f(int[] piles, int x) {
        long hours = 0;
        for (int i = 0; i < piles.length; i++) {
            // 都用整个小时吃完当前这棵树
            hours += piles[i] / x;
            if (piles[i] % x > 0) {
                hours++;
            }
        }
        return hours;
    }",O(n⋅logm),https://leetcode.com/problems/koko-eating-bananas/
153,Find Minimum in Rotated Sorted Array,BinarySearch,二分法模版：和nums[right]做比较,"public int findMin(int[] nums) {
     int len = nums.length;
     int left = 0, right = len - 1;
     while (left < right) {
         int mid = left + (right - left) / 2;
         if (nums[mid] > nums[right]) {
              left = mid + 1;
         }  else {
              right = mid;
         }
       }
   return nums[left];
}",logn,https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/
33,Search in Rotated Sorted Array,BinarySearch,先找到pivot，然后在左右区间分别搜索target（因为pivot的值是最小值）,,,https://leetcode.com/problems/search-in-rotated-sorted-array/description/
981,Time Based Key-Value Store,BinarySearch,,,,https://leetcode.com/problems/time-based-key-value-store/description/
4,Median of Two Sorted Arrays,BinarySearch,"注意edge cases的处理

明白题意","class TimeMap {
    private Map<String, List<Element>> timeMap;
    public TimeMap() {
        timeMap = new HashMap<>();
    }
    
    public void set(String key, String value, int timestamp) {
        List<Element> list = timeMap.getOrDefault(key, new ArrayList<>());
        list.add(new Element(value, timestamp));
        timeMap.put(key, list);
    }
    
    public String get(String key, int timestamp) {
        List<Element> list = timeMap.get(key);
        if (list == null) return """";
        int left = 0, right = list.size() - 1;
        // 查找时间，移动index
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (list.get(mid).timestamp > timestamp) {
                right = mid - 1;
            }
            else if (list.get(mid).timestamp < timestamp) {
                left = mid + 1;
            }
            else return list.get(mid).value;
        }
        // left是key对应的timestamp应该在的位置，我们应该找prev，所以减1 （因为没有exactly timestamp一样的value）
        if (left - 1 < 0) return """"; // 越界不合法
        return list.get(left - 1).value;
    }
}

class Element {
    String value;
    int timestamp;
    public Element(String value, int timestamp) {
        this.value = value;
        this.timestamp = timestamp;
    }
}",,https://leetcode.com/problems/median-of-two-sorted-arrays/description/
4,Median of Two Sorted Arrays,BinarySearch,,,,https://leetcode.com/problems/median-of-two-sorted-arrays/description/
206,Reverse Linked List,"LinkedList, Recursion",1mins,,,
21,Merge Two Sorted Lists,"LinkedList, Two Pointer",1mins,,,https://leetcode.com/problems/merge-two-sorted-lists/description/
143,Reorder List,"LinkedList, Stack",5mins,"需要一个stack来得到lastnode, 还有三个指针在不停的变换，curr, next, last

while break的条件(next == last || next == last.next) 奇偶数",,https://leetcode.com/problems/reorder-list/description/
19,Remove Nth Node From End of List,"DummyNode, LinkedList, Two Pointer",pay attention on details,"需要使用双指针，实现one pass

我们找的是前一个node，所以还要考虑原本链表没有前一个node的情况，所以需要dummy先给原链表接上

return dummy.next",,https://leetcode.com/problems/remove-nth-node-from-end-of-list/
138,Copy List with Random Pointer,"Deep Copy, LinkedList",8mins,"deep copy的题都要用bfs和map

类似于copy graph，动作同步

class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) return null;
        Map<Node, Node> copyMap = new HashMap<>();
        Queue<Node> bfsQueue = new LinkedList<>();
        bfsQueue.offer(head);
        copyMap.put(head, new Node(head.val));
        while (!bfsQueue.isEmpty()) {
            Node curr = bfsQueue.poll();
            Node copyCurr = copyMap.get(curr);
            if (curr.random != null && !copyMap.containsKey(curr.random)) {
                bfsQueue.offer(curr.random);
                Node copyNode = new Node(curr.random.val);
                copyMap.put(curr.random, copyNode);
            }
            if (curr.next != null && !copyMap.containsKey(curr.next)) {
                bfsQueue.offer(curr.next);
                Node copyNode = new Node(curr.next.val);
                copyMap.put(curr.next, copyNode);
            }
            Node copyNext = copyMap.get(curr.next);
            Node copyRandom = copyMap.get(curr.random);
            copyCurr.next = copyNext;
            copyCurr.random = copyRandom;
        }
        return copyMap.get(head);
    }
}",,https://leetcode.com/problems/copy-list-with-random-pointer/description/
2,Add Two Numbers,"DummyNode, LinkedList, Two Pointer",5mins,while (l1 != null || l2 != null || carry != 0),,https://leetcode.com/problems/add-two-numbers/description/
141,Linked List Cycle,"LinkedList, Two Pointer",1mins,,,https://leetcode.com/problems/linked-list-cycle/description/
287,Find the Duplicate Number,"Floyd's Algorithm, LinkedList, Two Pointer",5mins,"public int findDuplicate(int[] nums) {
      int slowIdx = 0, fastIdx = 0; 
      while (true) {
            slowIdx = nums[slowIdx];
            fastIdx = nums[nums[fastIdx]];
            if (slowIdx == fastIdx) {
            int flag = 0;
            while (flag != slowIdx) {
                 flag = nums[flag];
                slowIdx = nums[slowIdx];
            }
         return flag;
       }
    }
}",Time O(n) Space O(1),https://leetcode.com/problems/find-the-duplicate-number/description/
146,LRU Cache,"DoubleLinkedList, HashMap",20mins,"需要自己建造DoubleLinkedList 对应有method →  moveToHead, removeNode, addToHead

注意细节","• Time complexity : O(1) both for put and get.

• Space complexity : O(capacity) since the space is used only for a hashmap and double linked list with at most capacity + 1 elements.",https://leetcode.com/problems/lru-cache/description/
23,Merge k Sorted Lists,"LinkedList, PriorityQueue",5mins,,,
25,Reverse Nodes in k-Group,"LinkedList, Recursion",forgot → 巧妙的使用递归,"    public ListNode reverseKGroup(ListNode head, int k) {
        if (head == null) return null;
        ListNode a = head, b = head;
        for (int i = 0; i < k; i++) {
            if (b == null) return a;
            b = b.next;
        }
        ListNode newHead = reverse(a, b);
        a.next = reverseKGroup(b, k);
        return newHead;
    }

    public ListNode reverse(ListNode a, ListNode b) {
        ListNode pre = null, temp = null;
        ListNode curr = a;
        while (curr != b) {
            temp = curr.next;
            curr.next = pre;
            pre = curr;
            curr = temp;
        }
        return pre;
    }",,https://leetcode.com/problems/reverse-nodes-in-k-group/description/
226,Invert Binary Tree,Tree,1mins,Post Order Traversal → 构造,,https://leetcode.com/problems/invert-binary-tree/description/
104,Maximum Depth of Binary Tree,Tree,1mins,Post Order Traversal → 算高度,,https://leetcode.com/problems/maximum-depth-of-binary-tree/description/
543,Diameter of Binary Tree,Tree,2mins,结合maxdepth method,,https://leetcode.com/problems/diameter-of-binary-tree/description/
110,Balanced Binary Tree,Tree,2mins,结合maxdepth method,,https://leetcode.com/problems/balanced-binary-tree/description/
100,Same Tree,Tree,2mins,Preorder traversal,,https://leetcode.com/problems/same-tree/description/
572,Subtree of Another Tree,Tree,"4mins

结合same tree","class Solution {
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {
        if (root == null && subRoot == null) return true;
        if (root == null || subRoot == null) return false;
        if (isSameTree(root, subRoot)) return true;
        return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);
    }

    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) return true;
        if (p == null || q == null) return false;
        if (p.val != q.val) return false;
        boolean left = isSameTree(p.left, q.left);
        boolean right = isSameTree(p.right, q.right);
        return left && right;
    }
}",,https://leetcode.com/problems/subtree-of-another-tree/description/
235,Lowest Common Ancestor of a Binary Search Tree,BST,take advantage of the property of BST → range,,,https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/
199,Binary Tree Right Side View,"BFS, Level Traversal, Tree",3mins,"if (i == size - 1) {
    res.add(curr.val);
}",,https://leetcode.com/problems/binary-tree-right-side-view/description/
1448,Count Good Nodes in Binary Tree,Tree,"8mins

需要keep一个最大值，当目前值是大于或等于最大值时，说明这条path是合法的

使用前序遍历","    private int cnt;
    public int goodNodes(TreeNode root) {
        cnt = 0;
        helper(root, root.val);
        return cnt;
    }

    public void helper(TreeNode root, int max) {
        if (root == null) return;
        if (root.val >= max) {
            cnt++;
            max = root.val;
        }
        helper(root.left, max);
        helper(root.right, max);
    }",,https://leetcode.com/problems/count-good-nodes-in-binary-tree/description/
98,Validate Binary Search Tree,BST,3mins,"carry a range, comparing the root’s value with range",,https://leetcode.com/problems/validate-binary-search-tree/description/
230,Kth Smallest Element in a BST,BST,4mins,全局变量加上中序遍历,,https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/
105,Construct Binary Tree from Preorder and Inorder Traversal,Tree,5mins,后序遍历进行构造，需要利用hashmap查找坐标，这样才能算出左子树的长度，才能进行双指针的移动,,https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/
124,Binary Tree Maximum Path Sum,Tree,5mins,"后序遍历，构建贡献值的概念 > 0

    private int maxSum;
    public int maxPathSum(TreeNode root) {
        maxSum = Integer.MIN_VALUE;
        helper(root);
        return maxSum;
    }

    public int helper(TreeNode root) {
        if (root == null) return 0;
        int left = helper(root.left);
        int right = helper(root.right);
        maxSum = Math.max(maxSum, left + right + root.val);
        if (left + root.val < 0 && right + root.val < 0) return 0;
        return left > right ? left + root.val : right + root.val;
    }",,https://leetcode.com/problems/binary-tree-maximum-path-sum/description/
297,Serialize and Deserialize Binary Tree,Tree,"12mins

需要一个delimiter用于分割，也需要当遇到null的时候，插入一个null的字符，这样，当我们重构tree的时候，遇见null string，说明我们应该返回null了

同时需要一个全局变量指针

前序构建string

后序构造tree

为什么能构造unique的，也是因为我们插入了分隔符号还有null string","    private int p = 0;
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        preorderTraversal(root, sb);
        return sb.toString();
    }

    public void preorderTraversal(TreeNode root, StringBuilder sb) {
        if (root == null) {
            sb.append(""null"");
            sb.append("","");
            return;
        }
        sb.append(root.val);
        sb.append("","");
        preorderTraversal(root.left, sb);
        preorderTraversal(root.right, sb);
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        String[] tokens = data.split("","");
        return postorderTraversal(tokens);
    }

    public TreeNode postorderTraversal(String[] tokens) {
        if (tokens[p].equals(""null"")) {
            p++;
            return null;
        }
        int rootVal = Integer.parseInt(tokens[p]);
        p++;
        TreeNode left = postorderTraversal(tokens);
        TreeNode right = postorderTraversal(tokens);
        TreeNode node = new TreeNode(rootVal);
        node.left = left;
        node.right = right;
        return node;
    }",,https://leetcode.com/problems/serialize-and-deserialize-binary-tree/description/
449,Serialize and Deserialize BST,BST,用297的算法能过，但是没有利用 bst的性质 ：左大右小,"    private int p = 0;
    
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        toStringPreorderTraversal(root, sb);
        return sb.toString();
    }
    
    public void toStringPreorderTraversal(TreeNode root, StringBuilder sb) {
        if (root == null) {
            return;
        }
        sb.append(root.val);
        sb.append("","");
        toStringPreorderTraversal(root.left, sb);
        toStringPreorderTraversal(root.right, sb);
    }

    // Decodes your encoded data to tree.
    // 2, 1, 3
    public TreeNode deserialize(String data) {
        // edge case 
        if (data.equals("""")) return null;
        String[] tokens = data.split("","");
        return toTreeNodePreorderTraversal(tokens, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }
    
    public TreeNode toTreeNodePreorderTraversal(String[] tokens, int min, int max) {
        // 需要这个结束，是因为 我们并没有把null计算进去
        if (p >= tokens.length) {
            return null;
        }
        // 判断当前值是否存在与当前区域
        int currVal = Integer.parseInt(tokens[p]);
        if (currVal < min || currVal > max) {
            return null;
        }
        TreeNode root = new TreeNode(currVal);
        p++;
        root.left = toTreeNodePreorderTraversal(tokens, min, currVal);
        root.right = toTreeNodePreorderTraversal(tokens, currVal, max);
        return root;
    }",,https://leetcode.com/problems/serialize-and-deserialize-bst/description/
208,Implement Trie (Prefix Tree),Trie,5mins,"class TrieNode {
       public Map<Character, TrieNode> children;
       public boolean isEnd;
       public TrieNode() {
           children = new HashMap<>();
           isEnd = false;
    }
}

模版题",,https://leetcode.com/problems/implement-trie-prefix-tree/description/
211,Design Add and Search Words Data Structure,Trie,12mins,"因为带pattern，那么我们就需要把每一种可能进行搜索，dfs

for循环",,https://leetcode.com/problems/design-add-and-search-words-data-structure/description/
212,Word Search II,Trie,12mins,把所要求的word放入trie，然后再进行搜索,,https://leetcode.com/problems/word-search-ii/description/
703,Kth Largest Element in a Stream,PriorityQueue,5mins,kth largest element in the sorted order → 用最小堆，保持队列的个数，队列头就是第k大的数字,,https://leetcode.com/problems/kth-largest-element-in-a-stream/
1046,Last Stone Weight,PriorityQueue,2mins,,,https://leetcode.com/problems/last-stone-weight/description/
973,K Closest Points to Origin,QuickSelect,15mins,"对距离进行比较

    private int resIdx;
    private Random random;
    public int[][] kClosest(int[][] points, int k) {
        random = new Random();
        resIdx = k - 1;
        quickSelect(0, points.length - 1, points);
        int[][] res = new int[k][2];
        for (int i = 0; i < k; i++) {
            res[i] = points[i];
        }
        return res;
    }

    public void quickSelect(int left, int right, int[][] points) {
        int idx = partition(points, left, right);
        if (idx == resIdx) return;
        if (idx > resIdx) {
            quickSelect(0, idx - 1, points) ;
        } else {
            quickSelect(idx + 1, right, points);
        }
    }

    public int partition(int[][] points, int left, int right) {
        int randomIdx = random.nextInt(right - left + 1) + left;
        swap(points, randomIdx, left);
        double pivot = getDistance(points[left]);
        int j = left;
        for (int i = left + 1; i <= right; i++) {
            if (getDistance(points[i]) < pivot) {
                j++;
                swap(points, j, i);
            }
        }
        swap(points, left, j);
        return j;
    }

    public void swap(int[][] points, int x, int y) {
        int[] temp = points[x];
        points[x] = points[y];
        points[y] = temp;
    }

    public double getDistance(int[] coordinate) {
        int x = coordinate[0], y = coordinate[1];
        return Math.sqrt(x * x + y * y);
    }","• Time Complexity: O(N) in average case and O(N2) in the worst case, where N is the length of points.
• Space Complexity: O(N).",https://leetcode.com/problems/k-closest-points-to-origin/description/
215,Kth Largest Element in an Array,QuickSelect,15mins,"    private int resIdx;
    private Random random;
    public int findKthLargest(int[] nums, int k) {
        resIdx = nums.length - k;
        random = new Random();
        quickSelect(nums, 0, nums.length - 1);
        return nums[resIdx];
    }
    public void quickSelect(int[] nums, int left, int right) {
        int idx = partition(nums, left, right);
        if (idx == resIdx) return;
        if (idx > resIdx) {
            quickSelect(nums, left, idx - 1);
        } else {
            quickSelect(nums, idx + 1, right);
        }
    }
    public int partition(int[] nums, int left, int right) {
        int randomIdx = random.nextInt(right - left + 1) + left;
        swap(nums, left, randomIdx);
        int pivot = nums[left];
        int j = left;
        for (int i = left + 1; i <= right; i++) {
            if (nums[i] < pivot) {
                j++;
                swap(nums, i, j);
            }
        }
        swap(nums, j, left);
        return j;
    }

    public void swap(int[] nums, int x, int y) {
        int temp = nums[x];
        nums[x] = nums[y];
        nums[y] = temp;
    }",,https://leetcode.com/problems/kth-largest-element-in-an-array/
621,Task Scheduler,PriorityQueue,"15mins

need to pay attention on timestamp + 1","class Solution {
    public int leastInterval(char[] tasks, int n) {
        PriorityQueue<Task> pq = new PriorityQueue<>((t1, t2) -> t1.timestamp - t2.timestamp);
        Map<Character, Integer> cnt = new HashMap<>();
        for (char task : tasks) {
            cnt.put(task, cnt.getOrDefault(task, 0) + 1);
        }
        for (char task : cnt.keySet()) {
            pq.offer(new Task(task, cnt.get(task)));
        }
        int currTime = 0;
        while (!pq.isEmpty()) {
            Task currTask = pq.peek();
            if (currTime >= currTask.timestamp) {
                pq.poll();
                currTime++;
                currTask.timestamp += n + 1;
                currTask.num--;
                if (currTask.num != 0) {
                    pq.offer(currTask);
                }
            } else {
                currTime = currTask.timestamp;
            }
        }
        return currTime;
    }
}

class Task {
    public int timestamp;
    public char task;
    public int num;
    public Task(char task, int num) {
        timestamp = 0;
        this.task = task;
        this.num = num;
    }
}",,https://leetcode.com/problems/task-scheduler/description/
295,Find Median from Data Stream,PriorityQueue,"leftPart是大顶堆，rightPart是小顶堆

始终保持leftpart的个数比rightpart多一个","    private PriorityQueue<Integer> leftPart;
    private PriorityQueue<Integer> rightPart;
    public MedianFinder() {
        leftPart = new PriorityQueue<>((n1, n2) -> n2 - n1);
        rightPart = new PriorityQueue<>();
    }
    
    public void addNum(int num) {
        if (leftPart.size() == rightPart.size()) {
            rightPart.offer(num);
            leftPart.offer(rightPart.poll());
        } else {
            leftPart.offer(num);
            rightPart.offer(leftPart.poll());
        }
    }
    
    public double findMedian() {
        if (leftPart.size() == rightPart.size()) {
            return (leftPart.peek() + rightPart.peek()) / 2.0;
        }
        return leftPart.peek();
    }",,https://leetcode.com/problems/find-median-from-data-stream/description/
90,Subsets II,Backtracking,sort → 去掉重复组合,"    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        backtracking(nums, res, new ArrayList<>(), 0);
        return res;
    }

    public void backtracking(int[] nums, List<List<Integer>> res, List<Integer> list, int start) {
        res.add(new ArrayList<>(list));
        // if (start == nums.length) return;
        for (int i = start; i < nums.length; i++) {
            int curr = nums[i];
            if (i > start && nums[i - 1] == curr) continue;
            list.add(curr);
            backtracking(nums, res, list, i + 1);
            list.remove(list.size() - 1);
        }
    }",,https://leetcode.com/problems/subsets-ii/description/
40,Combination Sum II,Backtracking,在于如何prune,"    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<List<Integer>> res = new ArrayList<>();
        backtracking(candidates, res, new ArrayList<>(), target, 0, 0);
        return res;
    }

    public void backtracking(int[] candidates, List<List<Integer>> res, List<Integer> list, int target, int sum, int start) {
        if (sum == target) {
            res.add(new ArrayList<>(list));
            return;
        }
        for (int i = start; i < candidates.length; i++) {
            int curr = candidates[i];
            if (i > start && curr == candidates[i - 1]) continue;
            if (sum + curr > target) break;
            list.add(curr);
            backtracking(candidates, res, list, target, sum + curr, i + 1);
            list.remove(list.size() - 1);
        }
    }",,https://leetcode.com/problems/combination-sum-ii/
79,Word Search,Backtracking,10mins,"if (start == word.length()) return true;
if (x < 0 || x >= board.length || y < 0 || y >= board[0].length || word.charAt(start) != board[x][y] || board[x][y] == '.') return false;",,https://leetcode.com/problems/word-search/
78,Subsets,Backtracking,2mins,,,https://leetcode.com/problems/subsets/description/
39,Combination Sum,Backtracking,3mins,,,https://leetcode.com/problems/combination-sum/description/
46,Permutations,Backtracking,5mins,需要一个visited来记录已经存放过的位置，和combination不一样，这个不需要start,,https://leetcode.com/problems/permutations/description/
131,Palindrome Partitioning,Backtracking,5mins,先使用中心扩展法，对token进行预处理，再使用backtracking,,https://leetcode.com/problems/palindrome-partitioning/description/
17,Letter Combinations of a Phone Number,Backtracking,8mins,"先使用map进行查找，再使用backtracking进行组合

    public List<String> letterCombinations(String digits) {
        List<String> res = new ArrayList<>();
        if (digits == null || digits.length() == 0) return res;
        Map<Character, String> map = new HashMap<>();
        map.put('2', ""abc"");
        map.put('3', ""def"");
        map.put('4', ""ghi"");
        map.put('5', ""jkl"");
        map.put('6', ""mno"");
        map.put('7', ""pqrs"");
        map.put('8', ""tuv"");
        map.put('9', ""wxyz"");
        backtracking(res, new StringBuilder(), digits, map, 0);
        return res;
    }

    public void backtracking(List<String> res, StringBuilder sb, String digits, Map<Character, String> map, int idx) {
        if (sb.length() == digits.length()) {
            res.add(sb.toString());
            return;
        }
        String curr = map.get(digits.charAt(idx));
        for (int i = 0; i < curr.length(); i++) {
            sb.append(curr.charAt(i));
            backtracking(res, sb, digits, map, idx + 1);
            sb.setLength(sb.length() - 1);
        }
    }",,https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/
51,N-Queens,Backtracking,15mins,"根据row来进行填补

检查左右对角线，和正上部分

    private char[][] chessboard;
    private int n;
    public List<List<String>> solveNQueens(int n) {
        chessboard = new char[n][n];
        this.n = n;
        for (int i = 0; i < n; i++) {
            Arrays.fill(chessboard[i], '.');
        }
        List<List<String>> res = new ArrayList<>();
        // fill according to row
        backtracking(res, 0);
        return res;
    }

    public void backtracking(List<List<String>> res, int row) {
        if (row == n) {
            List<String> curr = chessboardToString(chessboard);
            res.add(curr);
            return;
        }
        for (int i = 0; i < n; i++) {
            if (check(chessboard, row, i)) {
                chessboard[row][i] = 'Q';
                backtracking(res, row + 1);
                chessboard[row][i] = '.';
            }
        }
    }

    public List<String> chessboardToString(char[][] chessboard) {
        List<String> list = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            list.add(new String(chessboard[i]));
        }
        return list;
    }

    public boolean check(char[][] chessboard, int row, int col) {
        // diagonal , left part
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (chessboard[i][j] == 'Q') return false;
        }

        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if (chessboard[i][j] == 'Q') return false;
        }

        for (int i = row - 1; i >= 0; i--) {
            if (chessboard[i][col] == 'Q') return false;
        }
        return true;
    }",,https://leetcode.com/problems/n-queens/description/
200,Number of Islands,Graph,2mins,,,https://leetcode.com/problems/number-of-islands/description/
133,Clone Graph,"BFS, Graph","10mins

没有创建过的才放入bfs queue中，防止尝试死循环","    public Node cloneGraph(Node node) {
        Map<Node, Node> copyMap = new HashMap<>();
        Queue<Node> bfsQueue = new LinkedList<>();
        if (node == null) return null;
        bfsQueue.offer(node);
        copyMap.put(node, new Node(node.val));
        while (!bfsQueue.isEmpty()) {
            Node curr = bfsQueue.poll();
            Node copy = copyMap.get(curr);
            for (Node neighbor : curr.neighbors) {
                if (!copyMap.containsKey(neighbor)) {
                    bfsQueue.offer(neighbor);
                }
                Node copyNeighbor =  copyMap.getOrDefault(neighbor, new Node(neighbor.val));
                copy.neighbors.add(copyNeighbor);
                copyMap.put(neighbor, copyNeighbor);
            }
        }
        return copyMap.get(node);
    }",,https://leetcode.com/problems/clone-graph/description/
695,Max Area of Island,Graph,2mins,,,https://leetcode.com/problems/max-area-of-island/description/
417,Pacific Atlantic Water Flow,Graph,"15mins

从边界开始dfs","    public List<List<Integer>> pacificAtlantic(int[][] heights) {
        int rows = heights.length, cols = heights[0].length;
        boolean[][] pacific = new boolean[rows][cols];
        boolean[][] atlantic = new boolean[rows][cols];
        for (int i = 0; i < rows; i++) {
            dfs(pacific, heights, i, 0, 0);
            dfs(atlantic, heights, i, cols - 1, 0);
        }
        for (int j = 0; j < cols; j++) {
            dfs(pacific, heights, 0, j, 0);
            dfs(atlantic, heights, rows - 1, j, 0);
        }
        List<List<Integer>> res = new ArrayList<>();
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (pacific[i][j] && atlantic[i][j]) {
                    List<Integer> list = new ArrayList<>();
                    list.add(i);
                    list.add(j);
                    res.add(list);
                }
            }
        }
        return res;
    }

    public void dfs(boolean[][] ocean, int[][] heights, int x, int y, int prevHeight) {
        if (x < 0 || x >= heights.length || y < 0 || y >= heights[0].length || ocean[x][y] || heights[x][y] < prevHeight) return;
        ocean[x][y] = true;
        dfs(ocean, heights, x + 1, y, heights[x][y]);
        dfs(ocean, heights, x - 1, y, heights[x][y]);
        dfs(ocean, heights, x, y + 1, heights[x][y]);
        dfs(ocean, heights, x, y - 1, heights[x][y]);
    }",O(M * N),https://leetcode.com/problems/pacific-atlantic-water-flow/description/
130,Surrounded Regions,Graph,"6mins

也是从边界开始进行dfs","    public void solve(char[][] board) {
        int rows = board.length, cols = board[0].length;
        boolean[][] notCaptured = new boolean[rows][cols];
        for (int i = 0; i < rows; i++) {
            dfs(notCaptured, board, i, 0);
            dfs(notCaptured, board, i, cols - 1);
        }

        for (int j = 0; j < cols; j++) {
            dfs(notCaptured, board, 0, j);
            dfs(notCaptured, board, rows - 1, j);
        }
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (board[i][j] == 'O' && !notCaptured[i][j]) {
                    board[i][j] = 'X';
                }
            }
        }
    }

    public void dfs(boolean[][] notCaptured, char[][] board, int x, int y) {
        if (x < 0 || x >= board.length || y < 0 || y >= board[0].length || notCaptured[x][y] || board[x][y] != 'O') return;
        notCaptured[x][y] = true;
        dfs(notCaptured, board, x + 1, y);
        dfs(notCaptured, board, x - 1, y);
        dfs(notCaptured, board, x, y + 1);
        dfs(notCaptured, board, x, y - 1);
    }",,https://leetcode.com/problems/surrounded-regions/description/
994,Rotting Oranges,"BFS, Graph","10mins

这题tricky的地方在于考虑edge cases， 本是全部都是好的，那么min是0，return 0，如果有坏的 那么return min - 1

如果还有好的橘子，那么return -1","    public int orangesRotting(int[][] grid) {
        Queue<int[]> bfsQueue = new LinkedList<>();
        int rows = grid.length, cols = grid[0].length;
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (grid[i][j] == 2) {
                    bfsQueue.offer(new int[]{i, j});
                }
            }
        }
        int[][] directions = new int[][] {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        int min = 0;
        while (!bfsQueue.isEmpty()) {
            int size = bfsQueue.size();
            for (int i = 0; i < size; i++) {
                int[] curr = bfsQueue.poll();
                int x = curr[0], y = curr[1];
                for (int j = 0; j < 4; j++) {
                    int newX = x + directions[j][0], newY = y + directions[j][1];
                    if (newX < 0 || newX >= rows || newY < 0 || newY >= cols || grid[newX][newY] != 1) continue;
                    grid[newX][newY] = 2;
                    bfsQueue.offer(new int[] {newX, newY});
                }
            }
            min++;
        }
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (grid[i][j] == 1) {
                    return -1;
                }
            }
        }
        return min == 0 ? 0 : min - 1;
    }",O(M * N),https://leetcode.com/problems/rotting-oranges/description/
286,Walls and Gates,Graph,5mins,最小距离都应该想到bfs,O(M * N),https://leetcode.com/problems/walls-and-gates/description/
207,Course Schedule,Graph,6mins,使用map建立graph，再使用一个indegree map → bfs,,https://leetcode.com/problems/course-schedule/description/
210,Course Schedule II,Graph,8mins,注意edge case,,https://leetcode.com/problems/course-schedule-ii/description/
684,Redundant Connection,UnionFind,15mins,"主要注意find函数的书写

public int find (int x) {
       // rootX是旧root
        int rootX = parents[x];
        if (x != rootX) {
            parents[x] =  find(rootX);
        }
        // return已经被替换过的新root
       return parents[x];
}",,https://leetcode.com/problems/redundant-connection/description/
323,Number of Connected Components in an Undirected Graph,UnionFind,5mins,UF模版题,,https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/description/
261,Graph Valid Tree,UnionFind,5mins,,,https://leetcode.com/problems/graph-valid-tree/description/
127,Word Ladder,"BFS, Graph",15mins,"求最短距离和变换最少次数要想着使用bfs

    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Set<String> dict = new HashSet<>();
        for (String word : wordList) {
            dict.add(word);
        }
        if (!dict.contains(endWord)) return 0;
        int steps = 0;
        Queue<String> bfsQueue = new LinkedList<>();
        Set<String> visited = new HashSet<>();
        visited.add(beginWord);
        bfsQueue.offer(beginWord);
        while (!bfsQueue.isEmpty()) {
            int size = bfsQueue.size();
            for (int i = 0; i < size; i++) {
                String curr = bfsQueue.poll();
                if (curr.equals(endWord)) return steps + 1;
                for (int j = 0; j < curr.length(); j++) {
                    List<String> next = transform(curr, j);
                    for (String str : next) {
                        if (visited.contains(str) || !dict.contains(str)) continue;
                        bfsQueue.offer(str);
                        visited.add(str);
                    }
                }
            }
            steps++;
        }
        return 0;
    }

    public List<String> transform(String str, int idx) {
        char c = str.charAt(idx);
        char[] arr = str.toCharArray();
        List<String> res = new ArrayList<>();
        for (int i = 0; i < 26; i++) {
            if ((char)('a' + i) != c) {
                arr[idx] = (char)('a' + i);
            }
            res.add(new String(arr));
        }
        return res;
    }",,https://leetcode.com/problems/word-ladder/description/
332,Reconstruct Itinerary,"DFS, Graph, Greedy","Forget → how to construct the map used to avoid duplicately search

sort的目的 → 每次尝试都走最小的","    private int numCity;
    private Map<String, Map<String, Integer>> startToEndsTicketsNum = new HashMap<>();
    private Map<String, List<String>> graph = new HashMap<>();
    public List<String> findItinerary(List<List<String>> tickets) {
        numCity = tickets.size() + 1;        
        for (List<String> ticket : tickets) {
            String start = ticket.get(0), end = ticket.get(1);
            Map<String, Integer> startToSpecificEndTicketsNum = startToEndsTicketsNum.getOrDefault(start, new HashMap<>());
            startToSpecificEndTicketsNum.put(end, startToSpecificEndTicketsNum.getOrDefault(end, 0) + 1);
            startToEndsTicketsNum.put(start, startToSpecificEndTicketsNum);
            List<String> ends = graph.getOrDefault(start, new ArrayList<>());
            ends.add(end);
            graph.put(start, ends);
        }
        // If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.
        for (List<String> list : graph.values()) {
            Collections.sort(list);
        }
        List<String> res = new ArrayList<>();
        res.add(""JFK"");
        dfs(res, ""JFK"");
        return res;
    }
    
    public boolean dfs(List<String> res, String depature) {
        // if the city number that we have visited equals to the numCity, it denotes that current arrangement is feasible
        if (res.size() == numCity) {
            return true;
        }
        // terminate condition
        if (!graph.containsKey(depature)) {
            return false;
        }
        List<String> ends =  graph.get(depature);
        for (int i = 0; i < ends.size(); i++) {
            String end = ends.get(i);
            // it means that we have used this ticket before
            if (startToEndsTicketsNum.get(depature).get(end) == 0) continue;
            res.add(end);
            // ticket used
            startToEndsTicketsNum.get(depature).put(end, startToEndsTicketsNum.get(depature).get(end) - 1);
            if (dfs(res, end)) return true;
            // rollback
            startToEndsTicketsNum.get(depature).put(end, startToEndsTicketsNum.get(depature).get(end) + 1);
            res.remove(res.size() - 1);
        }
        return false;
    }",,https://leetcode.com/problems/reconstruct-itinerary/description/
1584,Min Cost to Connect All Points,"Graph, Greedy, UnionFind","Forget → 题目很好，很tricky

最重要的是数组的构造","class Solution {
    public int minCostConnectPoints(int[][] points) {
        int n = points.length;
        int combinationCnt = (n - 1) * n / 2;
        // [pointA idx in points, pointB idx in points, dist Between A and B]
        int[][] pointsAndDist = new int[combinationCnt][3];
        int idx = 0;
        for (int i = 0; i < n - 1; i++) {
            for (int j = i + 1; j < n; j++) {
                pointsAndDist[idx][0] = i;
                pointsAndDist[idx][1] = j; 
                pointsAndDist[idx][2] = getDist(points[i], points[j]);
                idx++;
            }
        }
        // greedy -> 从最短的距离开始选择
        Arrays.sort(pointsAndDist, (n1, n2) -> n1[2] - n2[2]);
        UF uf = new UF(n);
        int minCost = 0;
        for (int[] info : pointsAndDist) {
            int pointAIdx = info[0], pointBIdx = info[1];
            // 已经链接过
            if (uf.isConnected(pointAIdx, pointBIdx)) continue;
            uf.union(pointAIdx, pointBIdx);
            minCost += info[2];
        }
        return minCost;
    }

    public int getDist(int[] x, int[] y) {
        return Math.abs(x[0] - y[0]) + Math.abs(x[1] - y[1]);
    }
}

class UF {
    private int[] parents;
    public UF(int n) {
        parents = new int[n];
        for (int i = 0; i < n; i++) {
            parents[i] = i;
        }
    }

    public int find(int x) {
        int rootX = parents[x];
        if (x != rootX) {
            parents[x] = find(rootX);
        }
        return parents[x];
    }

    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY) return;
        parents[rootX] = rootY;
    }

    public boolean isConnected(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        return rootX == rootY;
    }
}",,https://leetcode.com/problems/min-cost-to-connect-all-points/description/
743,Network Delay Time,"Dijkstra, Graph",使用pq或者queue都是可以的,"    public int networkDelayTime(int[][] times, int n, int k) {
        Map<Integer, List<int[]>> graph = new HashMap<>();
        for (int[] time : times) {
            int start = time[0], end = time[1], cost = time[2];
            List<int[]> list = graph.getOrDefault(start, new ArrayList<>());
            int[] info = new int[2];
            info[0] = end;
            info[1] = cost;
            list.add(info);
            graph.put(start, list);
        }
        // record the min distance
        int[] fromStartToCurrDist = new int[n + 1];

        Arrays.fill(fromStartToCurrDist, Integer.MAX_VALUE);
        dijkstra(graph, fromStartToCurrDist, k);
        int res = 0;
        // 因为0的位置一直没有用
        for (int i = 1; i <=n ; i++) {
            int distance = fromStartToCurrDist[i];
            if (distance == Integer.MAX_VALUE) return -1;
            res = Math.max(res, distance);
        }
        return res;
    }

    public void dijkstra(Map<Integer, List<int[]>> graph, int[] fromStartToCurrDist, int start) {
        // 其实queue和pq都可以，pq相对会快一点
        // 先排耗时小的
        PriorityQueue<int[]> pq = new PriorityQueue<>((n1, n2) -> n1[1] - n2[1]);
        pq.offer(new int[] {start, 0});
        fromStartToCurrDist[start] = 0;
        while (!pq.isEmpty()) {
            int[] curr = pq.poll();
            int currEnd = curr[0];
            if (!graph.containsKey(currEnd)) continue;
            for (int[] nextEndInfo : graph.get(currEnd)) {
                int fromStartToNextEndDist = fromStartToCurrDist[currEnd] + nextEndInfo[1];
                if (fromStartToNextEndDist < fromStartToCurrDist[nextEndInfo[0]]) {
                    fromStartToCurrDist[nextEndInfo[0]] = fromStartToNextEndDist;
                    pq.offer(nextEndInfo);
                }
            }
        }
    }",,https://leetcode.com/problems/network-delay-time/description/
778,Swim in Rising Water,"BFS, Graph",用最小堆当作bfs queue用来取queue中的最大值,"    public int swimInWater(int[][] grid) {
        int rows = grid.length, cols = grid[0].length;
        int[][] dirs = new int[][] {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        PriorityQueue<int[]> pq = new PriorityQueue<>((n1, n2) -> n1[2] - n2[2]);
        pq.offer(new int[] {0, 0, grid[0][0]});
        int minTime = 0;
        boolean[][] visited = new boolean[rows][cols];
        while (!pq.isEmpty()) {
            int[] curr = pq.poll();
            int x = curr[0], y = curr[1], height = curr[2];
            minTime = Math.max(minTime, height);
            if (x == rows -1 && y == cols - 1) return minTime;
            for (int i = 0; i < 4; i++) {
                int newX = dirs[i][0] + x;
                int newY = dirs[i][1] + y;
                if (newX < 0 || newX >= grid.length || newY < 0 || newY >= grid[0].length || visited[newX][newY]) continue;
                pq.offer(new int[] {newX, newY, grid[newX][newY]});
                visited[newX][newY] = true;
            }
        }
        return -1;
    }",,https://leetcode.com/problems/swim-in-rising-water/description/
787,Cheapest Flights Within K Stops,"BFS, Graph","忘记了 bfs queue里面存放的具体内容

应该存放: int[] {position, previous route cost}
bfs结束条件是层数和queue是否为空","    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
        if (src == dst) return 0;
        Map<Integer, List<int[]>> graph = new HashMap<>();
        for (int[] fight : flights) {
            int start = fight[0];
            int[] endPoint = new int[] {fight[1], fight[2]};
            List<int[]> list = graph.getOrDefault(start, new ArrayList<>());
            list.add(endPoint);
            graph.put(start, list);
        }
        int[] costArr = new int[n];
        Arrays.fill(costArr, Integer.MAX_VALUE);
        // 保证了放入queue的int[] {position, cost} 这个cost代表这个线路之前的cost
        Queue<int[]> bfs = new LinkedList<>();
        bfs.offer(new int[] {src, 0});
        int steps = 0;
        while (!bfs.isEmpty() && steps <= k) {
            int size = bfs.size();
            for (int i = 0; i < size; i++) {
                int[] start = bfs.poll();
                if (!graph.containsKey(start[0])) continue;
                for (int[] end : graph.get(start[0])) {
                    int currCost = start[1] + end[1];
                    if (currCost < costArr[end[0]]) {
                        costArr[end[0]] = currCost;
                        bfs.offer(new int[] {end[0], costArr[end[0]]});
                    }
                }
            }
            steps++;
        }
        return costArr[dst] == Integer.MAX_VALUE ? -1 : costArr[dst];
    }",,https://leetcode.com/problems/cheapest-flights-within-k-stops/description/
269,Alien Dictionary,"BFS, Graph",拓扑排序,"    public String alienOrder(String[] words) {
        Map<Character, Integer> indegree = new HashMap<>();
        Map<Character, List<Character>> graph = new HashMap<>();
        Set<Character> unique = new HashSet<>();
        for (int i = 0; i < words.length - 1; i++) {
            String currWord = words[i], nextWord = words[i + 1];
            int p1 = 0, p2 = 0;
            while (p1 < currWord.length() && p2 < nextWord.length()) {
                char c1 = currWord.charAt(p1), c2 = nextWord.charAt(p2);
                if (c1 == c2) {
                    p1++;
                    p2++;
                } else {
                    indegree.put(c2, indegree.getOrDefault(c2, 0) + 1);
                    List<Character> list = graph.getOrDefault(c1, new ArrayList<>());
                    list.add(c2);
                    graph.put(c1, list);
                    break;
                }
            }
            // 排除 abc ab 情况；如果两个word是完全相同的，p2 也会等于nextword长度，这种不能排除
            if (p2 == nextWord.length() && currWord.length() > nextWord.length()) return """";
        }
        for (String word : words) {
            for (char c : word.toCharArray()) {
                unique.add(c);
            }
        }
        Queue<Character> bfs = new LinkedList<>();
        for (char c : unique) {
            if (!indegree.containsKey(c)) {
                bfs.offer(c);
            }
        }
        String res = """";
        while (!bfs.isEmpty()) {
            char curr = bfs.poll();
            res += curr;
            if (!graph.containsKey(curr)) continue;
            for (char c : graph.get(curr)) {
                indegree.put(c, indegree.get(c) - 1);
                if (indegree.get(c) == 0) {
                    bfs.offer(c);
                }
            }
        }
        return res.length() == unique.size() ? res : """";
    }",,https://leetcode.com/problems/alien-dictionary/description/
70,Climbing Stairs,1D Dynamic Programming,1mins,dp[i] = dp[i - 1] + dp[i - 2],"Space O(n)
Time O(n)",https://leetcode.com/problems/climbing-stairs/
746,Min Cost Climbing Stairs,1D Dynamic Programming,"这题一定要画图才能搞清楚

没有想象中那么简单 → 把梯子画出来，横向的是层数，纵向的是cost

","    public int minCostClimbingStairs(int[] cost) {
        // The array's length should be 1 longer than the length of cost
        // This is because we can treat the ""top floor"" as a step to reach
        int minimumCost[] = new int[cost.length + 1];
        
        // Start iteration from step 2, since the minimum cost of reaching
        // step 0 and step 1 is 0
        for (int i = 2; i < minimumCost.length; i++) {
            int takeOneStep = minimumCost[i - 1] + cost[i - 1];
            int takeTwoSteps = minimumCost[i - 2] + cost[i - 2];
            minimumCost[i] = Math.min(takeOneStep, takeTwoSteps);
        }
        
        // The final element in minimumCost refers to the top floor
        return minimumCost[minimumCost.length - 1];
    }","Space O(n)
Time O(n)",https://leetcode.com/problems/min-cost-climbing-stairs/
198,House Robber,1D Dynamic Programming,3mins,注意edge case，如果没有住户 或者只有一个住户,"Space O(n)
Time O(n)",https://leetcode.com/problems/house-robber/
213,House Robber II,1D Dynamic Programming,两种rob的方式，不同的range，所以要考虑不同的偏移量,"    public int rob(int[] nums) {
        if (nums.length == 0) return 0;
        if (nums.length == 1) return nums[0];
        int max1 = robHelper(nums, 0, nums.length - 2);
        int max2 = robHelper(nums, 1, nums.length - 1);
        return Math.max(max1, max2);
    }

    public int robHelper(int[] nums, int left, int right) {
        int n = right - left + 1;
        if (n == 1) return nums[left];
        int[] dp = new int[n];
        dp[0] = nums[left];
        dp[1] = Math.max(nums[left], nums[left + 1]);
        for (int i = 2; i <= right - left; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i + left]);
        }
        return dp[n - 1];
    }","Space O(n)
Time O(n)",https://leetcode.com/problems/house-robber-ii/
5,Longest Palindromic Substring,Two Pointer,ExpandAroundCenter,"    public String longestPalindrome(String s) {
        String res = """";
        for (int i = 0; i < s.length(); i++) {
            String even = expandAroundCenter(s, i, i + 1);
            String odd = expandAroundCenter(s, i, i);
            String bigger = even.length() > odd.length() ? even : odd;
            if (bigger.length() > res.length()) {
                res = bigger;
            }
        }
        return res;
    }

    public String expandAroundCenter(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        return s.substring(left + 1, right);
    }","Space O(1)
Time O(n^2)",https://leetcode.com/problems/longest-palindromic-substring/description/
647,Palindromic Substrings,Two Pointer,ExpandAroundCenter,记录个数,"Space O(1)
Time O(n^2)",https://leetcode.com/problems/palindromic-substrings/description/
91,Decode Ways,1D Dynamic Programming,"状态与选择

只有两种选择 片段长度为1 或者 为2

然后把之前的合法分割次数累加","    public int numDecodings(String s) {
        int n = s.length();
        if (n == 0) return 0;
        if (s.charAt(0) == '0') return 0;
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            if (s.charAt(i - 1) != '0') {
                dp[i] += dp[i - 1];
            }
            if (s.charAt(i - 2) != '0' && Integer.parseInt(s.substring(i - 2, i)) <= 26) {
                dp[i] += dp[i - 2];
            }
        }
        return dp[n];
    }","Space O(n)
Time O(n)",https://leetcode.com/problems/decode-ways/description/
322,Coin Change,1D Dynamic Programming,当curr amount 大于 当前coin面值的时候才能进行兑换，但是此时的兑换可能不是兑换次数最少的，所以需要进行比较,"    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            for (int j = 0; j < coins.length; j++) {
                if (i >= coins[j] && dp[i - coins[j]] != Integer.MAX_VALUE) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
    }","Space O(n)
Time O(n * m)",https://leetcode.com/problems/coin-change/
152,Maximum Product Subarray,1D Dynamic Programming,"自成一体 或者 和前面链接起来
正负数的存在 → 所以需要min 和 max数组","    public int maxProduct(int[] nums) {
        int n = nums.length;
        int[] min = new int[n + 1];
        int[] max = new int[n + 1];
        min[0] = 1;
        max[0] = 1;
        // 1 2 3 -12 -48
        // 1 2 6 -2  4
        int res = Integer.MIN_VALUE;
        for (int i = 1; i <= n; i++) {
            // 自成一体 或者 和前面链接起来
            // 正负数的存在
            min[i] = Math.min(Math.min(min[i - 1] * nums[i - 1], nums[i - 1]), max[i - 1] * nums[i - 1]);
            max[i] = Math.max(Math.max(max[i - 1] * nums[i - 1], nums[i - 1]), min[i - 1] * nums[i - 1]);
            res = Math.max(res, max[i]);
        }
        return res;
    }","Space O(n)
Time O(n)",https://leetcode.com/problems/maximum-product-subarray/description/
139,Word Break,1D Dynamic Programming,动态规划和记忆搜索本质是一样的 → 动态规划是自底而上，记忆搜索是自上而下,"    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> wordDictSet = new HashSet<>(wordDict);
        int n = s.length();
        if (n == 0) return false;
        boolean[] dp = new boolean[n + 1];
        dp[0] = true;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < i; j++) {
                String fragment = s.substring(j, i);
                // 此时的fragment能被查找到且之前的substring也能被划分
                if (dp[j] && wordDictSet.contains(fragment)) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[n];
    }


// 记忆搜索
   private Set<String> dict;
    private int[] memo;
    public boolean wordBreak(String s, List<String> wordDict) {
        dict = new HashSet<>(wordDict);
        memo = new int[s.length()];
        return wordBreakHelper(s, 0);
    }

    public boolean wordBreakHelper(String s, int idx) {
        if (idx == s.length()) {
            return true;
        }
        if (memo[idx] == 1) return false;
        for (int i = idx; i < s.length(); i++) {
            String token = s.substring(idx, i + 1);
            if (!dict.contains(token)) {
                continue;
            }
            if (wordBreakHelper(s, i + 1)) {
                return true;
            }
        }
        memo[idx] = 1;
        return false;
    }","Space O(n)
Time O(n^2)",https://leetcode.com/problems/word-break/description/
300,Longest Increasing Subsequence,1D Dynamic Programming,最长的subsequence不一定在最后,"    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        if (n == 0) return 0;
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        int res = 1;
        for (int i = 1; i < n; i++) {
            int curr = nums[i];
            for (int j = 0; j < i; j++) {
                int prev = nums[j];
                if (prev < curr) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            res = Math.max(res, dp[i]);
        }
        return res;
    }","Space O(n)
Time O(n^2)",https://leetcode.com/problems/longest-increasing-subsequence/description/
416,Partition Equal Subset Sum,1D Dynamic Programming,背包问题,"    public boolean canPartition(int[] nums) {
        if (nums.length == 0) return false;
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        if (sum % 2 != 0) return false;
        sum /= 2;
        boolean[] dp = new boolean[sum + 1];
        dp[0] = true;
        // 类似于换硬币， 但是硬币只能用一次，所以硬币的循环应该在外层
        for (int curr : nums) {
            // 从最大值开始到当前面值
            for (int j = sum; j >= curr; j--) {
                // 判断是否能换
                dp[j] |= dp[j - curr];
            }
        }
        return dp[sum];
    }



    public boolean canPartition(int[] nums) {
        int sum = 0;
        for (int num : nums) sum += num;
        // 和为奇数时，不可能划分成两个和相等的集合
        if (sum % 2 != 0) return false;
        int n = nums.length;
        sum = sum / 2;
        boolean[][] dp = new boolean[n + 1][sum + 1];
        // base case
        for (int i = 0; i <= n; i++)
            dp[i][0] = true;

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= sum; j++) {
                if (j - nums[i - 1] < 0) {
                    // 背包容量不足，不能装入第 i 个物品
                    dp[i][j] = dp[i - 1][j];
                } else {
                    // 装入或不装入背包
                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];
                }
            }
        }
        return dp[n][sum];
    }",,https://leetcode.com/problems/partition-equal-subset-sum/description/
,,,,,,
,,,,,,