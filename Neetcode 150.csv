Question Number,Question Name,Tag,Time Using,Conclusion,Complexity,URL
217,Contains Duplicate,"Array, HashSet",1mins,set.add() 的简单运用,Time O(n) Space O(n),https://leetcode.com/problems/contains-duplicate/description/
242,Valid Anagram,"Array, HashSet",1mins,,,https://leetcode.com/problems/valid-anagram/description/
1,Two Sum,"Array, HashSet",1mins,,,https://leetcode.com/problems/two-sum/description/
49,Group Anagrams,"Array, HashSet",2mins,可以用char[] arr来记录cnt，这样new string的时候 可以直接用,,https://leetcode.com/problems/group-anagrams/description/
347,Top K Frequent Elements,"Array, QuickSelect",12mins,quickSelect 模版题,Time O(n) Space O(n),https://leetcode.com/problems/top-k-frequent-elements/description/
238,Product of Array Except Self,Array,"8mins

一开始res[i] indicates: 左边的product except itself

注意两个for loop的起始值","    public int[] productExceptSelf(int[] nums) {
        int len = nums.length;
        int[] res = new int[len];
        res[0] = 1;
        // [1, 1, 2, 6]
        for (int i = 1; i < len; i++) {
            res[i] = res[i - 1] * nums[i - 1];
        }
        int rightProduct = 1;
        // [24, 12, 8, 6]
        for (int i = len - 2; i >= 0; i--) {
            rightProduct *= nums[i + 1];
            res[i] *= rightProduct;
        }
        return res;
    }",,https://leetcode.com/problems/product-of-array-except-self/
36,Valid Sudoku,Array,6mins,"开辟额外数组来进行记录

遇到重复，那么return false","Time O(1) Space O(1)

constant",https://leetcode.com/problems/valid-sudoku/
271,Encode and Decode Strings,String,"8mins

len + delimiter + word

s.indexOf(”Delimiter”, startIdx)","    public String encode(List<String> strs) {
        StringBuilder sb = new StringBuilder();
        for (String str : strs) {
            int len = str.length();
            sb.append(len).append(""/"").append(str);
        }
        return sb.toString();
    }

    // Decodes a single string to a list of strings.
    public List<String> decode(String s) {
        int idxEnd = 0;
        List<String> res = new ArrayList<>();
        while (idxEnd < s.length()) {
            int idxDelimiter = s.indexOf(""/"", idxEnd);
            // 5/word1
            int len = Integer.parseInt(s.substring(idxEnd, idxDelimiter));
            idxEnd = idxDelimiter + len + 1;
            String word = s.substring(idxDelimiter + 1, idxEnd);
            res.add(word);
        }
        return res;
    }",,
128,Longest Consecutive Sequence,"Array, HashSet","3mins

","注意edge case 原本数组可能为空

所以初始化 int maxLen = 0;",Time O(n) Space O(n),https://leetcode.com/problems/longest-consecutive-sequence/description/
125,Valid Palindrome,"String, Two Pointer",1mins,,,
167,Two Sum II - Input Array Is Sorted,Two Pointer,3mins,"sort 过后的 一定得想到two point来逼近

另外一个是二分法",Time O(n) Space O(1),https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/
15,3Sum,Two Pointer,8mins,"注意去重

使用 continue 和 while

while (left < right && nums[right] == nums[--right]);

while (left < right && nums[left] == nums[++left]);

因为right和left本来就要移动，所以可以使用此写法",Time O(nlogn+n^2),https://leetcode.com/problems/3sum/
11,Container With Most Water,Two Pointer,2mins,"当宽变小，只有高点大，才能使得面积变大的可能

所以pointer移动规则，height低的移动",Time O(n) Space O(1),https://leetcode.com/problems/container-with-most-water/description/
42,Trapping Rain Water,Two Pointer,"Forgot the details

首尾双指针保持左右边界高度","    public int trap(int[] height) {
        int len = height.length;
        int left = 0, right = len - 1;
        int sum = 0;
        int leftMax = 0, rightMax = 0;
        // 首尾双指针，为了保持左右高度的边界
        while (left < right) {
            leftMax = Math.max(leftMax, height[left]);
            rightMax = Math.max(rightMax, height[right]);
            // 在脑海中构造接雨水的过程
            if (leftMax <= rightMax) {
                // 取小的且移动
                sum += leftMax - height[left];
                left++;
            } else {
                sum += rightMax - height[right];
                right--;
            }
        }
        return sum;
    }",Time O(n) Space O(1),https://leetcode.com/problems/trapping-rain-water/
121,Best Time to Buy and Sell Stock,Array,1mins,,Time O(n) Space O(1),https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/
3,Longest Substring Without Repeating Characters,"HashMap, Sliding Window",3mins,"shrink condition

while (cntMap.get(curr) > 1)",Time O(n) Space O(n),https://leetcode.com/problems/longest-substring-without-repeating-characters/description/
424,Longest Repeating Character Replacement,"Greedy, HashMap, Sliding Window","5mins

保留窗口了cnt最多的character → 使得最长","1、什么时候应该扩大窗口？
2、什么时候应该缩小窗口？
3、什么时候得到一个合法的答案？
针对本题，以上三个问题的答案是：
1、当可替换次数大于 0 时，扩大窗口，所有进入窗口的字符都进行替换，使得窗口内的所有元素都是重复的。
2、当可替换次数小于 0 时，缩小窗口，空余出更多可替换次数，以便之后继续扩大窗口。
3、只要可替换次数大于等于 0，窗口中的字符串都是重复的，我们想求的是一个最大窗口长度。


不用更新 windowMaxCount
因为只有 windowMaxCount 变得更大的时候才可能获得更长的重复子串，才会更新 res",Time O(n) Space O(n),https://leetcode.com/problems/longest-repeating-character-replacement/description/
567,Permutation in String,"HashMap, Sliding Window",10mins,"需要两个hashmap来分别记录

return trueif one of s1's permutations is the substring of s2  → 本质是anagram

当窗口的长度等于s1的时候，进行收缩

    public boolean checkInclusion(String s1, String s2) {
        // 本质是anagram
        if (s2.length() < s1.length()) return false;
        Map<Character, Integer> neededMap = new HashMap<>();
        for (char c : s1.toCharArray()) {
            neededMap.put(c, neededMap.getOrDefault(c, 0) + 1);
        }
        int valid = 0;
        Map<Character, Integer> windowMap = new HashMap<>();
        int left = 0, right = 0, len = s2.length();
        while (right < len) {
            char curr = s2.charAt(right);
            windowMap.put(curr, windowMap.getOrDefault(curr, 0) + 1);
            if (windowMap.get(curr).equals(neededMap.get(curr))) {
                valid++;
            }
            right++;
            if (right - left == s1.length()) {
                if (valid == neededMap.size()) return true;
                char remove = s2.charAt(left);
                if (windowMap.get(remove).equals(neededMap.get(remove))) {
                    valid--;
                }
                windowMap.put(remove, windowMap.get(remove) - 1);
                left++;
            }
        }
        return false;
    }",Time O(n) Space O(n),https://leetcode.com/problems/permutation-in-string/
76,Minimum Window Substring,"HashMap, Sliding Window",8mins,经典模版题,Time O(m+n),https://leetcode.com/problems/minimum-window-substring/description/
239,Sliding Window Maximum,"MaxQueue, Sliding Window",8mins,"利用deque来实现mxaQueue, 这样就能保持窗口中的最大值

    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer> maxQueue = new ArrayDeque<>();
        int left = 0, right = 0, len = nums.length;
        int[] maxArr = new int[len - k + 1];
        int p = 0;
        while (right < len) {
            int curr = nums[right];
            // maxQueue: max -> min
            while (!maxQueue.isEmpty() && curr > maxQueue.peekLast()) {
                maxQueue.pollLast();
            }
            maxQueue.offerLast(curr);
            right++;
            if (right - left > k) {
                int remove = nums[left];
                if (remove == maxQueue.peekFirst()) {
                    maxQueue.pollFirst();
                }
                left++;
            }
            if (right - left == k) {
                maxArr[p++] = maxQueue.peekFirst();
            }
        }
        return maxArr;
    }",Time O(n) Space O(n),https://leetcode.com/problems/sliding-window-maximum/description/
20,Valid Parentheses,"HashMap, Stack",3mins,right parentheses是key， left是value,Time O(n) Space O(n),https://leetcode.com/problems/valid-parentheses/description/
155,Min Stack,Stack,5mins,"Deque<Integer> origin;
Deque<Integer> minStk;

minStk的作用是保持最小状态",,https://leetcode.com/problems/min-stack/description/
150,Evaluate Reverse Polish Notation,Stack,"8mins

如果要使用deque来模拟stack，那么一定要使用offerLast and pollLast, 这样才不会出错","    public int evalRPN(String[] tokens) {
        Deque<Integer> stk = new ArrayDeque<>();
        for (String token : tokens) {
            if (token.equals(""*"") || token.equals(""/"") || token.equals(""+"") || token.equals(""-"")) {
                int num1 = stk.pollLast();
                int num2 = stk.pollLast();
                switch (token) {
                    case ""+"":
                        stk.offerLast(num2 + num1);
                        break;
                    case ""-"" :
                        stk.offerLast(num2 - num1);
                        break;
                    case ""*"" :
                        stk.offerLast(num2 * num1);
                        break;
                    default :
                        stk.offerLast(num2 / num1);
                        break;
                }
            } else {
                stk.offerLast(Integer.parseInt(token));
            }
        }
        return stk.pollLast();
    }",,https://leetcode.com/problems/evaluate-reverse-polish-notation/description/
22,Generate Parentheses,Backtracking,"10mins


注意添加parentheses的顺序和条件","    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();
        backtracking(res, new StringBuilder(), 0, 0, n);
        return res;
    }

    public void backtracking(List<String> res, StringBuilder sb, int leftCnt, int rightCnt, int n) {
        if (leftCnt == n && rightCnt == n) {
            res.add(sb.toString());
            return;
        }

        if (leftCnt < n) {
            sb.append(""("");
            backtracking(res, sb, leftCnt + 1, rightCnt, n);
            sb.setLength(sb.length() - 1);
        }

        if (rightCnt < leftCnt) {
            sb.append("")"");
            backtracking(res, sb, leftCnt, rightCnt + 1, n);
            sb.setLength(sb.length() - 1);
        }
    }",,https://leetcode.com/problems/generate-parentheses/description/
140,Word Break II,Backtracking,直接backtracking暴力搜索,"public List<String> wordBreak(String s, List<String> wordDict) {
        StringBuilder sb = new StringBuilder();
        List<String> res = new ArrayList<>();
        Set<String> dict = new HashSet<>();
        for (String word : wordDict) {
            dict.add(word);
        }
        backtracking(res, sb, dict, s, 0);
        return res;
    }

    public void backtracking(List<String> res, StringBuilder sb, Set<String> dict, String s, int idx) {
        if (idx == s.length()) {
            String temp = sb.toString();
            res.add(temp.substring(0, temp.length() -1));
            return;
        }
        for (int i = idx; i < s.length(); i++) {
            String token = s.substring(idx, i + 1);
            if (!dict.contains(token)) continue;
            int len = sb.length();
            sb.append(token);
            sb.append("" "");
            backtracking(res, sb, dict, s, i + 1);
            sb.setLength(len);
        }
    }",,https://leetcode.com/problems/word-break-ii/
739,Daily Temperatures,Stack,"5mins

monotonic （/ˌmɑnəˈtɑnɪk/） stack的运用， 放入的是idx",模版框架 for → while （pop）,Time O(n) Space O(n),https://leetcode.com/problems/daily-temperatures/
853,Car Fleet,Stack,"单调最大栈

在后面的车子: 到达终点所用的时间小于前面的车子，则一定能形成车队","    public int carFleet(int target, int[] position, int[] speed) {
        int len = position.length;
        int[][] cars = new int[len][2];
        for (int i = 0; i < len; i++) {
            cars[i][0] = position[i];
            cars[i][1] = speed[i];
        }
        Arrays.sort(cars, (n1, n2) -> (n1[0] - n2[0]));
        Stack<Double> stk = new Stack<>();
        // maxStack max -> min
        for (int i = 0; i < len; i++) {
            double time = (target - cars[i][0]) / (double)cars[i][1];
            while (!stk.isEmpty() && stk.peek() <= time) {
                stk.pop();
            }
            stk.push(time);
        }
        return stk.size();
    }",,https://leetcode.com/problems/car-fleet/description/
84,Largest Rectangle in Histogram,Stack,"单调最大栈，放入的是idx

min height → max height

当遇到一个更小的height时，会pop出左边界，preIdx = peek() 这时宽度 i -preIdx - 1, 高度是arr[左边界]

去掉重复计算","public int largestRectangleArea(int[] heights) {
    int len = heights.length;
    int[] arr = new int[len + 2];
    for (int i = 1; i <= len; i++) {
        arr[i] = heights[i - 1];
    }
    int maxArea = 0;
    Stack<Integer> monoMinStk = new Stack<>();
    for (int i = 0; i < arr.length; i++) {
         int currHeight = arr[i];
         while (!monoMinStk.isEmpty() && arr[monoMinStk.peek()] > currHeight) {
              int leftBoundaryIdx = monoMinStk.pop();
              int preIdx = monoMinStk.peek();
              int width = i - preIdx - 1;
              maxArea = Math.max(maxArea, width * arr[leftBoundaryIdx]);
          }
      monoMinStk.push(i);
     }
   return maxArea;
}",Time O(n) Space O(n),https://leetcode.com/problems/largest-rectangle-in-histogram/description/
704,Binary Search,BinarySearch,二分模版,,Time O(logn) Space O(1),https://leetcode.com/problems/binary-search/description/
74,Search a 2D Matrix,BinarySearch,5mins,"把二维二分搜索压缩成一维度的

int left = 0, right = m * n - 1;

int mid = left + (right - left) / 2;
int x = mid / n;
int y = mid % n;",O(log(m * n)),https://leetcode.com/problems/search-a-2d-matrix/description/
875,Koko Eating Bananas,BinarySearch,"难点在于如何构造单调递减函数

f(x)是关于速度x的单调递减函数(速度越快所用时间越短)，然后求左边界[1, maxSpeed]","public int minEatingSpeed(int[] piles, int h) {
        // the eating speed of koko is x, the y is the time of eating all of bananas. 
        // Monotonically decreasing function f(x) = ax + b;
        // binary search -> find the speed 

        int left = 1, right = 1000000001;
        // 求左边界
        while (left ≤ right) {
            int mid = left + (right - left) / 2;
            // 目标是速度越小时间尽量长，但满足要求
            if (f(piles, mid) <= h) {
                // 速度减小
                right = mid - 1;
            } else {
                // 总时间大于h，速度要加快
                left = mid + 1;
            }
        }
        return left;
    }

    public long f(int[] piles, int x) {
        long hours = 0;
        for (int i = 0; i < piles.length; i++) {
            // 都用整个小时吃完当前这棵树
            hours += piles[i] / x;
            if (piles[i] % x > 0) {
                hours++;
            }
        }
        return hours;
    }",O(n⋅logm),https://leetcode.com/problems/koko-eating-bananas/
153,Find Minimum in Rotated Sorted Array,BinarySearch,二分法模版：和nums[right]做比较,"public int findMin(int[] nums) {
     int len = nums.length;
     int left = 0, right = len - 1;
     while (left < right) {
         int mid = left + (right - left) / 2;
         if (nums[mid] > nums[right]) {
              left = mid + 1;
         }  else {
              right = mid;
         }
       }
   return nums[left];
}",logn,https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/
33,Search in Rotated Sorted Array,BinarySearch,先找到pivot，然后在左右区间分别搜索target（因为pivot的值是最小值）,,,https://leetcode.com/problems/search-in-rotated-sorted-array/description/
981,Time Based Key-Value Store,BinarySearch,,,,https://leetcode.com/problems/time-based-key-value-store/description/
4,Median of Two Sorted Arrays,BinarySearch,"注意edge cases的处理

明白题意","class TimeMap {
    private Map<String, List<Element>> timeMap;
    public TimeMap() {
        timeMap = new HashMap<>();
    }
    
    public void set(String key, String value, int timestamp) {
        List<Element> list = timeMap.getOrDefault(key, new ArrayList<>());
        list.add(new Element(value, timestamp));
        timeMap.put(key, list);
    }
    
    public String get(String key, int timestamp) {
        List<Element> list = timeMap.get(key);
        if (list == null) return """";
        int left = 0, right = list.size() - 1;
        // 查找时间，移动index
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (list.get(mid).timestamp > timestamp) {
                right = mid - 1;
            }
            else if (list.get(mid).timestamp < timestamp) {
                left = mid + 1;
            }
            else return list.get(mid).value;
        }
        // left是key对应的timestamp应该在的位置，我们应该找prev，所以减1 （因为没有exactly timestamp一样的value）
        if (left - 1 < 0) return """"; // 越界不合法
        return list.get(left - 1).value;
    }
}

class Element {
    String value;
    int timestamp;
    public Element(String value, int timestamp) {
        this.value = value;
        this.timestamp = timestamp;
    }
}",,https://leetcode.com/problems/median-of-two-sorted-arrays/description/
4,Median of Two Sorted Arrays,BinarySearch,,,,https://leetcode.com/problems/median-of-two-sorted-arrays/description/
206,Reverse Linked List,"LinkedList, Recursion",1mins,,,
21,Merge Two Sorted Lists,"LinkedList, Two Pointer",1mins,,,https://leetcode.com/problems/merge-two-sorted-lists/description/
143,Reorder List,"LinkedList, Stack",5mins,"需要一个stack来得到lastnode, 还有三个指针在不停的变换，curr, next, last

while break的条件(next == last || next == last.next) 奇偶数",,https://leetcode.com/problems/reorder-list/description/
19,Remove Nth Node From End of List,"DummyNode, LinkedList, Two Pointer",pay attention on details,"需要使用双指针，实现one pass

我们找的是前一个node，所以还要考虑原本链表没有前一个node的情况，所以需要dummy先给原链表接上

return dummy.next",,https://leetcode.com/problems/remove-nth-node-from-end-of-list/
138,Copy List with Random Pointer,"Deep Copy, LinkedList",8mins,"deep copy的题都要用bfs和map

类似于copy graph，动作同步

class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) return null;
        Map<Node, Node> copyMap = new HashMap<>();
        Queue<Node> bfsQueue = new LinkedList<>();
        bfsQueue.offer(head);
        copyMap.put(head, new Node(head.val));
        while (!bfsQueue.isEmpty()) {
            Node curr = bfsQueue.poll();
            Node copyCurr = copyMap.get(curr);
            if (curr.random != null && !copyMap.containsKey(curr.random)) {
                bfsQueue.offer(curr.random);
                Node copyNode = new Node(curr.random.val);
                copyMap.put(curr.random, copyNode);
            }
            if (curr.next != null && !copyMap.containsKey(curr.next)) {
                bfsQueue.offer(curr.next);
                Node copyNode = new Node(curr.next.val);
                copyMap.put(curr.next, copyNode);
            }
            Node copyNext = copyMap.get(curr.next);
            Node copyRandom = copyMap.get(curr.random);
            copyCurr.next = copyNext;
            copyCurr.random = copyRandom;
        }
        return copyMap.get(head);
    }
}",,https://leetcode.com/problems/copy-list-with-random-pointer/description/
2,Add Two Numbers,"DummyNode, LinkedList, Two Pointer",5mins,while (l1 != null || l2 != null || carry != 0),,https://leetcode.com/problems/add-two-numbers/description/
141,Linked List Cycle,"LinkedList, Two Pointer",1mins,,,https://leetcode.com/problems/linked-list-cycle/description/
287,Find the Duplicate Number,"Floyd's Algorithm, LinkedList, Two Pointer",5mins,"public int findDuplicate(int[] nums) {
      int slowIdx = 0, fastIdx = 0; 
      while (true) {
            slowIdx = nums[slowIdx];
            fastIdx = nums[nums[fastIdx]];
            if (slowIdx == fastIdx) {
            int flag = 0;
            while (flag != slowIdx) {
                 flag = nums[flag];
                slowIdx = nums[slowIdx];
            }
         return flag;
       }
    }
}",Time O(n) Space O(1),https://leetcode.com/problems/find-the-duplicate-number/description/
146,LRU Cache,"DoubleLinkedList, HashMap",20mins,"需要自己建造DoubleLinkedList 对应有method →  moveToHead, removeNode, addToHead

注意细节","• Time complexity : O(1) both for put and get.

• Space complexity : O(capacity) since the space is used only for a hashmap and double linked list with at most capacity + 1 elements.",https://leetcode.com/problems/lru-cache/description/
23,Merge k Sorted Lists,"LinkedList, PriorityQueue",5mins,,,
25,Reverse Nodes in k-Group,"LinkedList, Recursion",forgot → 巧妙的使用递归,"    public ListNode reverseKGroup(ListNode head, int k) {
        if (head == null) return null;
        ListNode a = head, b = head;
        for (int i = 0; i < k; i++) {
            if (b == null) return a;
            b = b.next;
        }
        ListNode newHead = reverse(a, b);
        a.next = reverseKGroup(b, k);
        return newHead;
    }

    public ListNode reverse(ListNode a, ListNode b) {
        ListNode pre = null, temp = null;
        ListNode curr = a;
        while (curr != b) {
            temp = curr.next;
            curr.next = pre;
            pre = curr;
            curr = temp;
        }
        return pre;
    }",,https://leetcode.com/problems/reverse-nodes-in-k-group/description/
226,Invert Binary Tree,Tree,1mins,Post Order Traversal → 构造,,https://leetcode.com/problems/invert-binary-tree/description/
104,Maximum Depth of Binary Tree,Tree,1mins,Post Order Traversal → 算高度,,https://leetcode.com/problems/maximum-depth-of-binary-tree/description/
543,Diameter of Binary Tree,Tree,2mins,结合maxdepth method,,https://leetcode.com/problems/diameter-of-binary-tree/description/
110,Balanced Binary Tree,Tree,2mins,结合maxdepth method,,https://leetcode.com/problems/balanced-binary-tree/description/
100,Same Tree,Tree,2mins,Preorder traversal,,https://leetcode.com/problems/same-tree/description/
572,Subtree of Another Tree,Tree,"4mins

结合same tree","class Solution {
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {
        if (root == null && subRoot == null) return true;
        if (root == null || subRoot == null) return false;
        if (isSameTree(root, subRoot)) return true;
        return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);
    }

    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) return true;
        if (p == null || q == null) return false;
        if (p.val != q.val) return false;
        boolean left = isSameTree(p.left, q.left);
        boolean right = isSameTree(p.right, q.right);
        return left && right;
    }
}",,https://leetcode.com/problems/subtree-of-another-tree/description/
235,Lowest Common Ancestor of a Binary Search Tree,BST,take advantage of the property of BST → range,,,https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/
199,Binary Tree Right Side View,"BFS, Level Traversal, Tree",3mins,"if (i == size - 1) {
    res.add(curr.val);
}",,https://leetcode.com/problems/binary-tree-right-side-view/description/
1448,Count Good Nodes in Binary Tree,Tree,"8mins

需要keep一个最大值，当目前值是大于或等于最大值时，说明这条path是合法的

使用前序遍历","    private int cnt;
    public int goodNodes(TreeNode root) {
        cnt = 0;
        helper(root, root.val);
        return cnt;
    }

    public void helper(TreeNode root, int max) {
        if (root == null) return;
        if (root.val >= max) {
            cnt++;
            max = root.val;
        }
        helper(root.left, max);
        helper(root.right, max);
    }",,https://leetcode.com/problems/count-good-nodes-in-binary-tree/description/
98,Validate Binary Search Tree,BST,3mins,"carry a range, comparing the root’s value with range",,https://leetcode.com/problems/validate-binary-search-tree/description/
230,Kth Smallest Element in a BST,BST,4mins,全局变量加上中序遍历,,https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/
105,Construct Binary Tree from Preorder and Inorder Traversal,Tree,5mins,后序遍历进行构造，需要利用hashmap查找坐标，这样才能算出左子树的长度，才能进行双指针的移动,,https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/
124,Binary Tree Maximum Path Sum,Tree,5mins,"后序遍历，构建贡献值的概念 > 0

    private int maxSum;
    public int maxPathSum(TreeNode root) {
        maxSum = Integer.MIN_VALUE;
        helper(root);
        return maxSum;
    }

    public int helper(TreeNode root) {
        if (root == null) return 0;
        int left = helper(root.left);
        int right = helper(root.right);
        maxSum = Math.max(maxSum, left + right + root.val);
        if (left + root.val < 0 && right + root.val < 0) return 0;
        return left > right ? left + root.val : right + root.val;
    }",,https://leetcode.com/problems/binary-tree-maximum-path-sum/description/
297,Serialize and Deserialize Binary Tree,Tree,"12mins

需要一个delimiter用于分割，也需要当遇到null的时候，插入一个null的字符，这样，当我们重构tree的时候，遇见null string，说明我们应该返回null了

同时需要一个全局变量指针

前序构建string

后序构造tree

为什么能构造unique的，也是因为我们插入了分隔符号还有null string","    private int p = 0;
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        preorderTraversal(root, sb);
        return sb.toString();
    }

    public void preorderTraversal(TreeNode root, StringBuilder sb) {
        if (root == null) {
            sb.append(""null"");
            sb.append("","");
            return;
        }
        sb.append(root.val);
        sb.append("","");
        preorderTraversal(root.left, sb);
        preorderTraversal(root.right, sb);
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        String[] tokens = data.split("","");
        return postorderTraversal(tokens);
    }

    public TreeNode postorderTraversal(String[] tokens) {
        if (tokens[p].equals(""null"")) {
            p++;
            return null;
        }
        int rootVal = Integer.parseInt(tokens[p]);
        p++;
        TreeNode left = postorderTraversal(tokens);
        TreeNode right = postorderTraversal(tokens);
        TreeNode node = new TreeNode(rootVal);
        node.left = left;
        node.right = right;
        return node;
    }",,https://leetcode.com/problems/serialize-and-deserialize-binary-tree/description/
449,Serialize and Deserialize BST,BST,用297的算法能过，但是没有利用 bst的性质 ：左大右小,"    private int p = 0;
    
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        toStringPreorderTraversal(root, sb);
        return sb.toString();
    }
    
    public void toStringPreorderTraversal(TreeNode root, StringBuilder sb) {
        if (root == null) {
            return;
        }
        sb.append(root.val);
        sb.append("","");
        toStringPreorderTraversal(root.left, sb);
        toStringPreorderTraversal(root.right, sb);
    }

    // Decodes your encoded data to tree.
    // 2, 1, 3
    public TreeNode deserialize(String data) {
        // edge case 
        if (data.equals("""")) return null;
        String[] tokens = data.split("","");
        return toTreeNodePreorderTraversal(tokens, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }
    
    public TreeNode toTreeNodePreorderTraversal(String[] tokens, int min, int max) {
        // 需要这个结束，是因为 我们并没有把null计算进去
        if (p >= tokens.length) {
            return null;
        }
        // 判断当前值是否存在与当前区域
        int currVal = Integer.parseInt(tokens[p]);
        if (currVal < min || currVal > max) {
            return null;
        }
        TreeNode root = new TreeNode(currVal);
        p++;
        root.left = toTreeNodePreorderTraversal(tokens, min, currVal);
        root.right = toTreeNodePreorderTraversal(tokens, currVal, max);
        return root;
    }",,https://leetcode.com/problems/serialize-and-deserialize-bst/description/
208,Implement Trie (Prefix Tree),Trie,5mins,"class TrieNode {
       public Map<Character, TrieNode> children;
       public boolean isEnd;
       public TrieNode() {
           children = new HashMap<>();
           isEnd = false;
    }
}

模版题",,https://leetcode.com/problems/implement-trie-prefix-tree/description/
211,Design Add and Search Words Data Structure,Trie,12mins,"因为带pattern，那么我们就需要把每一种可能进行搜索，dfs

for循环",,https://leetcode.com/problems/design-add-and-search-words-data-structure/description/
212,Word Search II,Trie,12mins,把所要求的word放入trie，然后再进行搜索,,https://leetcode.com/problems/word-search-ii/description/
703,Kth Largest Element in a Stream,PriorityQueue,5mins,kth largest element in the sorted order → 用最小堆，保持队列的个数，队列头就是第k大的数字,,https://leetcode.com/problems/kth-largest-element-in-a-stream/
1046,Last Stone Weight,PriorityQueue,2mins,,,https://leetcode.com/problems/last-stone-weight/description/
973,K Closest Points to Origin,QuickSelect,15mins,"对距离进行比较

    private int resIdx;
    private Random random;
    public int[][] kClosest(int[][] points, int k) {
        random = new Random();
        resIdx = k - 1;
        quickSelect(0, points.length - 1, points);
        int[][] res = new int[k][2];
        for (int i = 0; i < k; i++) {
            res[i] = points[i];
        }
        return res;
    }

    public void quickSelect(int left, int right, int[][] points) {
        int idx = partition(points, left, right);
        if (idx == resIdx) return;
        if (idx > resIdx) {
            quickSelect(0, idx - 1, points) ;
        } else {
            quickSelect(idx + 1, right, points);
        }
    }

    public int partition(int[][] points, int left, int right) {
        int randomIdx = random.nextInt(right - left + 1) + left;
        swap(points, randomIdx, left);
        double pivot = getDistance(points[left]);
        int j = left;
        for (int i = left + 1; i <= right; i++) {
            if (getDistance(points[i]) < pivot) {
                j++;
                swap(points, j, i);
            }
        }
        swap(points, left, j);
        return j;
    }

    public void swap(int[][] points, int x, int y) {
        int[] temp = points[x];
        points[x] = points[y];
        points[y] = temp;
    }

    public double getDistance(int[] coordinate) {
        int x = coordinate[0], y = coordinate[1];
        return Math.sqrt(x * x + y * y);
    }","• Time Complexity: O(N) in average case and O(N2) in the worst case, where N is the length of points.
• Space Complexity: O(N).",https://leetcode.com/problems/k-closest-points-to-origin/description/
215,Kth Largest Element in an Array,QuickSelect,15mins,"    private int resIdx;
    private Random random;
    public int findKthLargest(int[] nums, int k) {
        resIdx = nums.length - k;
        random = new Random();
        quickSelect(nums, 0, nums.length - 1);
        return nums[resIdx];
    }
    public void quickSelect(int[] nums, int left, int right) {
        int idx = partition(nums, left, right);
        if (idx == resIdx) return;
        if (idx > resIdx) {
            quickSelect(nums, left, idx - 1);
        } else {
            quickSelect(nums, idx + 1, right);
        }
    }
    public int partition(int[] nums, int left, int right) {
        int randomIdx = random.nextInt(right - left + 1) + left;
        swap(nums, left, randomIdx);
        int pivot = nums[left];
        int j = left;
        for (int i = left + 1; i <= right; i++) {
            if (nums[i] < pivot) {
                j++;
                swap(nums, i, j);
            }
        }
        swap(nums, j, left);
        return j;
    }

    public void swap(int[] nums, int x, int y) {
        int temp = nums[x];
        nums[x] = nums[y];
        nums[y] = temp;
    }",,https://leetcode.com/problems/kth-largest-element-in-an-array/
621,Task Scheduler,PriorityQueue,"15mins

need to pay attention on timestamp + 1","class Solution {
    public int leastInterval(char[] tasks, int n) {
        PriorityQueue<Task> pq = new PriorityQueue<>((t1, t2) -> t1.timestamp - t2.timestamp);
        Map<Character, Integer> cnt = new HashMap<>();
        for (char task : tasks) {
            cnt.put(task, cnt.getOrDefault(task, 0) + 1);
        }
        for (char task : cnt.keySet()) {
            pq.offer(new Task(task, cnt.get(task)));
        }
        int currTime = 0;
        while (!pq.isEmpty()) {
            Task currTask = pq.peek();
            if (currTime >= currTask.timestamp) {
                pq.poll();
                currTime++;
                currTask.timestamp += n + 1;
                currTask.num--;
                if (currTask.num != 0) {
                    pq.offer(currTask);
                }
            } else {
                currTime = currTask.timestamp;
            }
        }
        return currTime;
    }
}

class Task {
    public int timestamp;
    public char task;
    public int num;
    public Task(char task, int num) {
        timestamp = 0;
        this.task = task;
        this.num = num;
    }
}",,https://leetcode.com/problems/task-scheduler/description/
295,Find Median from Data Stream,PriorityQueue,"leftPart是大顶堆，rightPart是小顶堆

始终保持leftpart的个数比rightpart多一个","    private PriorityQueue<Integer> leftPart;
    private PriorityQueue<Integer> rightPart;
    public MedianFinder() {
        leftPart = new PriorityQueue<>((n1, n2) -> n2 - n1);
        rightPart = new PriorityQueue<>();
    }
    
    public void addNum(int num) {
        if (leftPart.size() == rightPart.size()) {
            rightPart.offer(num);
            leftPart.offer(rightPart.poll());
        } else {
            leftPart.offer(num);
            rightPart.offer(leftPart.poll());
        }
    }
    
    public double findMedian() {
        if (leftPart.size() == rightPart.size()) {
            return (leftPart.peek() + rightPart.peek()) / 2.0;
        }
        return leftPart.peek();
    }",,https://leetcode.com/problems/find-median-from-data-stream/description/
90,Subsets II,Backtracking,sort → 去掉重复组合,"    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        backtracking(nums, res, new ArrayList<>(), 0);
        return res;
    }

    public void backtracking(int[] nums, List<List<Integer>> res, List<Integer> list, int start) {
        res.add(new ArrayList<>(list));
        // if (start == nums.length) return;
        for (int i = start; i < nums.length; i++) {
            int curr = nums[i];
            if (i > start && nums[i - 1] == curr) continue;
            list.add(curr);
            backtracking(nums, res, list, i + 1);
            list.remove(list.size() - 1);
        }
    }",,https://leetcode.com/problems/subsets-ii/description/
40,Combination Sum II,Backtracking,在于如何prune,"    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<List<Integer>> res = new ArrayList<>();
        backtracking(candidates, res, new ArrayList<>(), target, 0, 0);
        return res;
    }

    public void backtracking(int[] candidates, List<List<Integer>> res, List<Integer> list, int target, int sum, int start) {
        if (sum == target) {
            res.add(new ArrayList<>(list));
            return;
        }
        for (int i = start; i < candidates.length; i++) {
            int curr = candidates[i];
            if (i > start && curr == candidates[i - 1]) continue;
            if (sum + curr > target) break;
            list.add(curr);
            backtracking(candidates, res, list, target, sum + curr, i + 1);
            list.remove(list.size() - 1);
        }
    }",,https://leetcode.com/problems/combination-sum-ii/
79,Word Search,Backtracking,10mins,"if (start == word.length()) return true;
if (x < 0 || x >= board.length || y < 0 || y >= board[0].length || word.charAt(start) != board[x][y] || board[x][y] == '.') return false;",,https://leetcode.com/problems/word-search/
78,Subsets,Backtracking,2mins,,,https://leetcode.com/problems/subsets/description/
39,Combination Sum,Backtracking,3mins,,,https://leetcode.com/problems/combination-sum/description/
46,Permutations,Backtracking,5mins,需要一个visited来记录已经存放过的位置，和combination不一样，这个不需要start,,https://leetcode.com/problems/permutations/description/
131,Palindrome Partitioning,Backtracking,5mins,先使用中心扩展法，对token进行预处理，再使用backtracking,,https://leetcode.com/problems/palindrome-partitioning/description/
17,Letter Combinations of a Phone Number,Backtracking,8mins,"先使用map进行查找，再使用backtracking进行组合

    public List<String> letterCombinations(String digits) {
        List<String> res = new ArrayList<>();
        if (digits == null || digits.length() == 0) return res;
        Map<Character, String> map = new HashMap<>();
        map.put('2', ""abc"");
        map.put('3', ""def"");
        map.put('4', ""ghi"");
        map.put('5', ""jkl"");
        map.put('6', ""mno"");
        map.put('7', ""pqrs"");
        map.put('8', ""tuv"");
        map.put('9', ""wxyz"");
        backtracking(res, new StringBuilder(), digits, map, 0);
        return res;
    }

    public void backtracking(List<String> res, StringBuilder sb, String digits, Map<Character, String> map, int idx) {
        if (sb.length() == digits.length()) {
            res.add(sb.toString());
            return;
        }
        String curr = map.get(digits.charAt(idx));
        for (int i = 0; i < curr.length(); i++) {
            sb.append(curr.charAt(i));
            backtracking(res, sb, digits, map, idx + 1);
            sb.setLength(sb.length() - 1);
        }
    }",,https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/
51,N-Queens,Backtracking,15mins,"根据row来进行填补

检查左右对角线，和正上部分

    private char[][] chessboard;
    private int n;
    public List<List<String>> solveNQueens(int n) {
        chessboard = new char[n][n];
        this.n = n;
        for (int i = 0; i < n; i++) {
            Arrays.fill(chessboard[i], '.');
        }
        List<List<String>> res = new ArrayList<>();
        // fill according to row
        backtracking(res, 0);
        return res;
    }

    public void backtracking(List<List<String>> res, int row) {
        if (row == n) {
            List<String> curr = chessboardToString(chessboard);
            res.add(curr);
            return;
        }
        for (int i = 0; i < n; i++) {
            if (check(chessboard, row, i)) {
                chessboard[row][i] = 'Q';
                backtracking(res, row + 1);
                chessboard[row][i] = '.';
            }
        }
    }

    public List<String> chessboardToString(char[][] chessboard) {
        List<String> list = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            list.add(new String(chessboard[i]));
        }
        return list;
    }

    public boolean check(char[][] chessboard, int row, int col) {
        // diagonal , left part
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (chessboard[i][j] == 'Q') return false;
        }

        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if (chessboard[i][j] == 'Q') return false;
        }

        for (int i = row - 1; i >= 0; i--) {
            if (chessboard[i][col] == 'Q') return false;
        }
        return true;
    }",,https://leetcode.com/problems/n-queens/description/